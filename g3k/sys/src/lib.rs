// Generated by gir (https://github.com/gtk-rs/gir @ 2358cc24efd2)
// from ../../gir-files (@ eab91ba8f88b)
// from ../../xrd-gir-files (@ 2f1ef32fd867)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(clippy::approx_constant, clippy::type_complexity, clippy::unreadable_literal, clippy::upper_case_acronyms)]
#![cfg_attr(feature = "dox", feature(doc_cfg))]


#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, intptr_t, uintptr_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

// Enums
pub type G3kAttributeType = c_int;
pub const G3K_ATTRIBUTE_TYPE_DOUBLE: G3kAttributeType = 0;
pub const G3K_ATTRIBUTE_TYPE_FLOAT: G3kAttributeType = 1;
pub const G3K_ATTRIBUTE_TYPE_UINT32: G3kAttributeType = 2;
pub const G3K_ATTRIBUTE_TYPE_INT32: G3kAttributeType = 3;
pub const G3K_ATTRIBUTE_TYPE_UINT16: G3kAttributeType = 4;
pub const G3K_ATTRIBUTE_TYPE_INT16: G3kAttributeType = 5;
pub const G3K_ATTRIBUTE_TYPE_UINT8: G3kAttributeType = 6;
pub const G3K_ATTRIBUTE_TYPE_INT8: G3kAttributeType = 7;

pub type G3kContainerAttachment = c_int;
pub const G3K_CONTAINER_ATTACHMENT_NONE: G3kContainerAttachment = 0;
pub const G3K_CONTAINER_ATTACHMENT_HEAD: G3kContainerAttachment = 1;
pub const G3K_CONTAINER_ATTACHMENT_HAND: G3kContainerAttachment = 2;

pub type G3kContainerLayout = c_int;
pub const G3K_CONTAINER_NO_LAYOUT: G3kContainerLayout = 0;
pub const G3K_CONTAINER_HORIZONTAL: G3kContainerLayout = 1;
pub const G3K_CONTAINER_VERTICAL: G3kContainerLayout = 2;
pub const G3K_CONTAINER_RELATIVE: G3kContainerLayout = 3;

pub type G3kHoverMode = c_int;
pub const G3K_HOVER_MODE_EVERYTHING: G3kHoverMode = 0;
pub const G3K_HOVER_MODE_BUTTONS: G3kHoverMode = 1;

pub type G3kLoaderError = c_int;
pub const G3K_LOADER_ERROR_FAIL: G3kLoaderError = 0;

pub type G3kRenderEventType = c_int;
pub const G3K_RENDER_EVENT_FRAME_START: G3kRenderEventType = 0;
pub const G3K_RENDER_EVENT_FRAME_END: G3kRenderEventType = 1;

pub type G3kTransformLock = c_int;
pub const XRD_TRANSFORM_LOCK_NONE: G3kTransformLock = 0;
pub const XRD_TRANSFORM_LOCK_PUSH_PULL: G3kTransformLock = 1;
pub const XRD_TRANSFORM_LOCK_SCALE: G3kTransformLock = 2;

// Flags
pub type G3kInteractionFlags = c_uint;
pub const G3K_INTERACTION_HOVERABLE: G3kInteractionFlags = 1;
pub const G3K_INTERACTION_DRAGGABLE: G3kInteractionFlags = 2;
pub const G3K_INTERACTION_MANAGED: G3kInteractionFlags = 4;
pub const G3K_INTERACTION_DESTROY_WITH_PARENT: G3kInteractionFlags = 8;
pub const G3K_INTERACTION_BUTTON: G3kInteractionFlags = 16;

// Records
#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kAccessor {
    pub array: *mut G3kAttributeArray,
    pub normalized: gboolean,
    pub item_size: size_t,
    pub item_offset: size_t,
    pub count: size_t,
}

impl ::std::fmt::Debug for G3kAccessor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kAccessor @ {self:p}"))
         .field("array", &self.array)
         .field("normalized", &self.normalized)
         .field("item_size", &self.item_size)
         .field("item_offset", &self.item_offset)
         .field("count", &self.count)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kAttributeArray {
    pub ref_count: c_int,
    pub type_: G3kAttributeType,
    pub stride: size_t,
    pub count: size_t,
    pub version: c_int,
    pub bytes: *mut glib::GBytes,
}

impl ::std::fmt::Debug for G3kAttributeArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kAttributeArray @ {self:p}"))
         .field("ref_count", &self.ref_count)
         .field("type_", &self.type_)
         .field("stride", &self.stride)
         .field("count", &self.count)
         .field("version", &self.version)
         .field("bytes", &self.bytes)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kBackgroundClass {
    pub parent_class: G3kObjectClass,
}

impl ::std::fmt::Debug for G3kBackgroundClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kBackgroundClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kButtonClass {
    pub parent: G3kPlaneClass,
}

impl ::std::fmt::Debug for G3kButtonClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kButtonClass @ {self:p}"))
         .field("parent", &self.parent)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kContainerClass {
    pub parent_class: G3kObjectClass,
}

impl ::std::fmt::Debug for G3kContainerClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kContainerClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kContextClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for G3kContextClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kContextClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kControllerClass {
    pub parent_class: G3kObjectClass,
}

impl ::std::fmt::Debug for G3kControllerClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kControllerClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kCursorClass {
    pub parent_class: G3kPlaneClass,
}

impl ::std::fmt::Debug for G3kCursorClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kCursorClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kGrabEvent {
    pub controller: *mut G3kController,
}

impl ::std::fmt::Debug for G3kGrabEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kGrabEvent @ {self:p}"))
         .field("controller", &self.controller)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kGrabState {
    pub object: *mut G3kObject,
    pub object_rotation: graphene::graphene_quaternion_t,
    pub inverse_controller_rotation: graphene::graphene_quaternion_t,
    pub offset: graphene::graphene_point_t,
    pub transform_lock: G3kTransformLock,
}

impl ::std::fmt::Debug for G3kGrabState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kGrabState @ {self:p}"))
         .field("object", &self.object)
         .field("object_rotation", &self.object_rotation)
         .field("inverse_controller_rotation", &self.inverse_controller_rotation)
         .field("offset", &self.offset)
         .field("transform_lock", &self.transform_lock)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kHoverEvent {
    pub point: graphene::graphene_point3d_t,
    pub pose: graphene::graphene_matrix_t,
    pub distance: c_float,
    pub controller: *mut G3kController,
}

impl ::std::fmt::Debug for G3kHoverEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kHoverEvent @ {self:p}"))
         .field("point", &self.point)
         .field("pose", &self.pose)
         .field("distance", &self.distance)
         .field("controller", &self.controller)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kHoverState {
    pub object: *mut G3kObject,
    pub distance: c_float,
    pub intersection_2d: graphene::graphene_point_t,
}

impl ::std::fmt::Debug for G3kHoverState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kHoverState @ {self:p}"))
         .field("object", &self.object)
         .field("distance", &self.distance)
         .field("intersection_2d", &self.intersection_2d)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kKeyEvent {
    pub string: *const c_char,
    pub keyval: c_uint,
}

impl ::std::fmt::Debug for G3kKeyEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kKeyEvent @ {self:p}"))
         .field("string", &self.string)
         .field("keyval", &self.keyval)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kKeyboardButtonClass {
    pub parent_class: G3kButtonClass,
}

impl ::std::fmt::Debug for G3kKeyboardButtonClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kKeyboardButtonClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kKeyboardClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for G3kKeyboardClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kKeyboardClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kLoaderClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for G3kLoaderClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kLoaderClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kMaterialClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for G3kMaterialClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kMaterialClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kMeshClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for G3kMeshClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kMeshClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kModelClass {
    pub parent_class: G3kObjectClass,
}

impl ::std::fmt::Debug for G3kModelClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kModelClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kNoHoverEvent {
    pub controller: *mut G3kController,
}

impl ::std::fmt::Debug for G3kNoHoverEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kNoHoverEvent @ {self:p}"))
         .field("controller", &self.controller)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kObjectClass {
    pub parent: gobject::GObjectClass,
    pub draw: Option<unsafe extern "C" fn(*mut G3kObject, vulkan::VkCommandBuffer)>,
    pub get_intersection: Option<unsafe extern "C" fn(*mut G3kObject, *mut graphene::graphene_ray_t, *mut c_float, *mut graphene::graphene_point3d_t) -> gboolean>,
    pub update_selection: Option<unsafe extern "C" fn(*mut G3kObject, *mut G3kSelection) -> gboolean>,
}

impl ::std::fmt::Debug for G3kObjectClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kObjectClass @ {self:p}"))
         .field("parent", &self.parent)
         .field("draw", &self.draw)
         .field("get_intersection", &self.get_intersection)
         .field("update_selection", &self.update_selection)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kObjectManagerClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for G3kObjectManagerClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kObjectManagerClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kPipelineClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for G3kPipelineClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kPipelineClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kPlaneClass {
    pub parent: G3kObjectClass,
    pub init_mesh: Option<unsafe extern "C" fn(*mut G3kPlane) -> *mut gulkan::GulkanVertexBuffer>,
    pub update_texture_size: Option<unsafe extern "C" fn(*mut G3kPlane)>,
    pub get_content_extent: Option<unsafe extern "C" fn(*mut G3kPlane) -> vulkan::VkExtent2D>,
}

impl ::std::fmt::Debug for G3kPlaneClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kPlaneClass @ {self:p}"))
         .field("parent", &self.parent)
         .field("init_mesh", &self.init_mesh)
         .field("update_texture_size", &self.update_texture_size)
         .field("get_content_extent", &self.get_content_extent)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kPlaneUniformBuffer {
    pub mvp: [c_float; 32],
}

impl ::std::fmt::Debug for G3kPlaneUniformBuffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kPlaneUniformBuffer @ {self:p}"))
         .field("mvp", &self.mvp)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kPose {
    pub position: graphene::graphene_point3d_t,
    pub rotation: graphene::graphene_quaternion_t,
}

impl ::std::fmt::Debug for G3kPose {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kPose @ {self:p}"))
         .field("position", &self.position)
         .field("rotation", &self.rotation)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kPrimitiveClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for G3kPrimitiveClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kPrimitiveClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kRayClass {
    pub parent_class: G3kObjectClass,
}

impl ::std::fmt::Debug for G3kRayClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kRayClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kRenderEvent {
    pub type_: G3kRenderEventType,
}

impl ::std::fmt::Debug for G3kRenderEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kRenderEvent @ {self:p}"))
         .field("type_", &self.type_)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kRendererClass {
    pub parent_class: gulkan::GulkanRendererClass,
}

impl ::std::fmt::Debug for G3kRendererClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kRendererClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kSamplerClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for G3kSamplerClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kSamplerClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kSelectionClass {
    pub parent_class: G3kObjectClass,
}

impl ::std::fmt::Debug for G3kSelectionClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kSelectionClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kTipClass {
    pub parent_class: G3kPlaneClass,
}

impl ::std::fmt::Debug for G3kTipClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kTipClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kTransformTransition {
    pub object: *mut G3kObject,
    pub from: graphene::graphene_matrix_t,
    pub to: graphene::graphene_matrix_t,
    pub interpolate: c_float,
    pub last_timestamp: i64,
}

impl ::std::fmt::Debug for G3kTransformTransition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kTransformTransition @ {self:p}"))
         .field("object", &self.object)
         .field("from", &self.from)
         .field("to", &self.to)
         .field("interpolate", &self.interpolate)
         .field("last_timestamp", &self.last_timestamp)
         .finish()
    }
}

// Classes
#[repr(C)]
pub struct G3kBackground {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for G3kBackground {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kBackground @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kButton {
    pub parent_instance: G3kPlane,
}

impl ::std::fmt::Debug for G3kButton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kButton @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
pub struct G3kContainer {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for G3kContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kContainer @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct G3kContext {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for G3kContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kContext @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct G3kController {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for G3kController {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kController @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct G3kCursor {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for G3kCursor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kCursor @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct G3kKeyboard {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for G3kKeyboard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kKeyboard @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct G3kKeyboardButton {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for G3kKeyboardButton {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kKeyboardButton @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kLoader {
    pub parent: gobject::GObject,
}

impl ::std::fmt::Debug for G3kLoader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kLoader @ {self:p}"))
         .field("parent", &self.parent)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kMaterial {
    pub parent: gobject::GObject,
    pub context: *mut G3kContext,
    pub name: *mut c_char,
    pub ao_map_intensity: c_float,
    pub normal_scale: graphene::graphene_vec2_t,
    pub emissive: graphene::graphene_vec3_t,
    pub emissive_intensity: c_float,
    pub color: graphene::graphene_vec3_t,
    pub color_alpha: c_float,
    pub roughness: c_float,
    pub metalness: c_float,
    pub alpha_test: c_float,
    pub double_sided: gboolean,
    pub transparent: gboolean,
    pub textures: *mut glib::GHashTable,
    pub buffer: *mut gulkan::GulkanUniformBuffer,
}

impl ::std::fmt::Debug for G3kMaterial {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kMaterial @ {self:p}"))
         .field("parent", &self.parent)
         .field("context", &self.context)
         .field("name", &self.name)
         .field("ao_map_intensity", &self.ao_map_intensity)
         .field("normal_scale", &self.normal_scale)
         .field("emissive", &self.emissive)
         .field("emissive_intensity", &self.emissive_intensity)
         .field("color", &self.color)
         .field("color_alpha", &self.color_alpha)
         .field("roughness", &self.roughness)
         .field("metalness", &self.metalness)
         .field("alpha_test", &self.alpha_test)
         .field("double_sided", &self.double_sided)
         .field("transparent", &self.transparent)
         .field("textures", &self.textures)
         .field("buffer", &self.buffer)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kMesh {
    pub parent: gobject::GObject,
    pub name: *mut c_char,
    pub primitives: *mut glib::GPtrArray,
}

impl ::std::fmt::Debug for G3kMesh {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kMesh @ {self:p}"))
         .field("parent", &self.parent)
         .field("name", &self.name)
         .field("primitives", &self.primitives)
         .finish()
    }
}

#[repr(C)]
pub struct G3kModel {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for G3kModel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kModel @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kObject {
    pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for G3kObject {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kObject @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
pub struct G3kObjectManager {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for G3kObjectManager {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kObjectManager @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct G3kPipeline {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for G3kPipeline {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kPipeline @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct G3kPlane {
    pub parent_instance: G3kObject,
}

impl ::std::fmt::Debug for G3kPlane {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kPlane @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
pub struct G3kPrimitive {
    pub parent: gobject::GObject,
    pub context: *mut G3kContext,
    pub accessors: *mut glib::GHashTable,
    pub index_accessor: *mut G3kAccessor,
    pub index_count: size_t,
    _truncated_record_marker: c_void,
    // /*Ignored*/field index_type has incomplete type
}

impl ::std::fmt::Debug for G3kPrimitive {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kPrimitive @ {self:p}"))
         .field("parent", &self.parent)
         .field("context", &self.context)
         .field("accessors", &self.accessors)
         .field("index_accessor", &self.index_accessor)
         .field("index_count", &self.index_count)
         .finish()
    }
}

#[repr(C)]
pub struct G3kRay {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for G3kRay {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kRay @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct G3kRenderer {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for G3kRenderer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kRenderer @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct G3kSampler {
    pub parent: gobject::GObject,
    _truncated_record_marker: c_void,
    // /*Ignored*/field mag_filter has incomplete type
}

impl ::std::fmt::Debug for G3kSampler {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kSampler @ {self:p}"))
         .field("parent", &self.parent)
         .finish()
    }
}

#[repr(C)]
pub struct G3kSelection {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for G3kSelection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kSelection @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct G3kTip {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for G3kTip {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("G3kTip @ {self:p}"))
         .finish()
    }
}

#[link(name = "g3k-0.16")]
extern "C" {

    //=========================================================================
    // G3kAttributeArray
    //=========================================================================
    pub fn g3k_attribute_array_ref(array: *mut G3kAttributeArray) -> *mut G3kAttributeArray;
    pub fn g3k_attribute_array_unref(array: *mut G3kAttributeArray);
    pub fn g3k_attribute_array_new(type_: G3kAttributeType, count: size_t, stride: size_t) -> *mut G3kAttributeArray;

    //=========================================================================
    // G3kPose
    //=========================================================================
    pub fn g3k_pose_init_from_pose(pose: *mut G3kPose, other: *mut G3kPose);
    pub fn g3k_pose_to_matrix(pose: *mut G3kPose, out_transform: *mut graphene::graphene_matrix_t);
    pub fn g3k_pose_validate(pose: *mut G3kPose) -> gboolean;
    pub fn g3k_pose_new(position: *mut graphene::graphene_point3d_t, rotation: *mut graphene::graphene_quaternion_t) -> G3kPose;
    pub fn g3k_pose_new_from_matrix(m: *mut graphene::graphene_matrix_t) -> G3kPose;

    //=========================================================================
    // G3kBackground
    //=========================================================================
    pub fn g3k_background_get_type() -> GType;
    pub fn g3k_background_new(g3k: *mut G3kContext) -> *mut G3kBackground;

    //=========================================================================
    // G3kButton
    //=========================================================================
    pub fn g3k_button_get_type() -> GType;
    pub fn g3k_button_new(g3k: *mut G3kContext, size_meters: *mut graphene::graphene_size_t) -> *mut G3kButton;
    pub fn g3k_button_reset_color(self_: *mut G3kButton);
    pub fn g3k_button_set_color(self_: *mut G3kButton, color: *const graphene::graphene_vec4_t);
    pub fn g3k_button_set_icon(self_: *mut G3kButton, url: *const c_char);
    pub fn g3k_button_set_selection_color(self_: *mut G3kButton, is_selected: gboolean);
    pub fn g3k_button_set_text(self_: *mut G3kButton, label_count: c_int, label: *mut *mut c_char);

    //=========================================================================
    // G3kContainer
    //=========================================================================
    pub fn g3k_container_get_type() -> GType;
    pub fn g3k_container_new(context: *mut G3kContext) -> *mut G3kContainer;
    pub fn g3k_container_add_child(self_: *mut G3kContainer, object: *mut G3kObject, relative_transform: *mut graphene::graphene_matrix_t);
    pub fn g3k_container_center_view(self_: *mut G3kContainer, distance: c_float);
    pub fn g3k_container_get_children(self_: *mut G3kContainer) -> *mut glib::GSList;
    pub fn g3k_container_get_distance(self_: *mut G3kContainer) -> c_float;
    pub fn g3k_container_hide(self_: *mut G3kContainer);
    pub fn g3k_container_is_visible(self_: *mut G3kContainer) -> gboolean;
    pub fn g3k_container_remove_child(self_: *mut G3kContainer, object: *mut G3kObject);
    pub fn g3k_container_set_attachment(self_: *mut G3kContainer, attachment: G3kContainerAttachment, controller: *mut gxr::GxrController);
    pub fn g3k_container_set_distance(self_: *mut G3kContainer, distance: c_float);
    pub fn g3k_container_set_layout(self_: *mut G3kContainer, layout: G3kContainerLayout);
    pub fn g3k_container_show(self_: *mut G3kContainer);
    pub fn g3k_container_step(self_: *mut G3kContainer) -> gboolean;

    //=========================================================================
    // G3kContext
    //=========================================================================
    pub fn g3k_context_get_type() -> GType;
    pub fn g3k_context_new() -> *mut G3kContext;
    pub fn g3k_context_new_from_gxr(gxr: *mut gxr::GxrContext) -> *mut G3kContext;
    pub fn g3k_context_new_from_vulkan_extensions(instance_ext_list: *mut glib::GSList, device_ext_list: *mut glib::GSList) -> *mut G3kContext;
    pub fn g3k_context_new_full(instance_ext_list: *mut glib::GSList, device_ext_list: *mut glib::GSList, app_name: *mut c_char, app_version: u32) -> *mut G3kContext;
    pub fn g3k_context_get_controller(self_: *mut G3kContext, gxr_controller: *mut gxr::GxrController) -> *mut G3kController;
    pub fn g3k_context_get_controllers(self_: *mut G3kContext) -> *mut glib::GList;
    pub fn g3k_context_get_gulkan(self_: *mut G3kContext) -> *mut gulkan::GulkanContext;
    pub fn g3k_context_get_gxr(self_: *mut G3kContext) -> *mut gxr::GxrContext;
    pub fn g3k_context_get_manager(self_: *mut G3kContext) -> *mut G3kObjectManager;
    pub fn g3k_context_get_ms_since_last_poll(self_: *mut G3kContext) -> c_float;
    pub fn g3k_context_get_primary_controller(self_: *mut G3kContext) -> *mut G3kController;
    pub fn g3k_context_get_projections(self_: *mut G3kContext) -> *mut graphene::graphene_matrix_t;
    pub fn g3k_context_get_renderer(self_: *mut G3kContext) -> *mut G3kRenderer;
    pub fn g3k_context_get_root(self_: *mut G3kContext) -> *mut G3kObject;
    pub fn g3k_context_get_upload_layout(self_: *mut G3kContext) -> vulkan::VkImageLayout;
    pub fn g3k_context_get_views(self_: *mut G3kContext) -> *mut graphene::graphene_matrix_t;
    pub fn g3k_context_get_vps(self_: *mut G3kContext) -> *mut graphene::graphene_matrix_t;
    pub fn g3k_context_init_dummy_controller(self_: *mut G3kContext) -> *mut G3kController;
    pub fn g3k_context_is_controller_primary(self_: *mut G3kContext, controller: *mut G3kController) -> gboolean;
    pub fn g3k_context_make_controller_primary(self_: *mut G3kContext, controller: *mut G3kController);
    pub fn g3k_context_play_sound(self_: *mut G3kContext, event_id: *const c_char);
    pub fn g3k_context_play_sound_path(self_: *mut G3kContext, path: *const c_char);
    pub fn g3k_context_render(self_: *mut G3kContext);
    pub fn g3k_context_start_renderer(self_: *mut G3kContext) -> gboolean;

    //=========================================================================
    // G3kController
    //=========================================================================
    pub fn g3k_controller_get_type() -> GType;
    pub fn g3k_controller_new(g3k: *mut G3kContext, controller: *mut gxr::GxrController) -> *mut G3kController;
    pub fn g3k_controller_check_grab(self_: *mut G3kController);
    pub fn g3k_controller_check_release(self_: *mut G3kController);
    pub fn g3k_controller_drag_start(self_: *mut G3kController, grabbed_object: *mut G3kObject);
    pub fn g3k_controller_get_controller(self_: *mut G3kController) -> *mut gxr::GxrController;
    pub fn g3k_controller_get_grab_state(self_: *mut G3kController) -> *mut G3kGrabState;
    pub fn g3k_controller_get_hover_state(self_: *mut G3kController) -> *mut G3kHoverState;
    pub fn g3k_controller_get_intersection(self_: *mut G3kController, object: *mut G3kObject, distance: *mut c_float, intersection_point: *mut graphene::graphene_point3d_t) -> gboolean;
    pub fn g3k_controller_get_ray(self_: *mut G3kController) -> *mut G3kRay;
    pub fn g3k_controller_get_selection(self_: *mut G3kController) -> *mut G3kSelection;
    pub fn g3k_controller_get_tip(self_: *mut G3kController) -> *mut G3kTip;
    pub fn g3k_controller_hide_pointers(self_: *mut G3kController);
    pub fn g3k_controller_init_children(self_: *mut G3kController) -> gboolean;
    pub fn g3k_controller_reset_hover_state(self_: *mut G3kController);
    pub fn g3k_controller_set_haptic_action(self_: *mut G3kController, action: *mut gxr::GxrAction);
    pub fn g3k_controller_show_pointers(self_: *mut G3kController);
    pub fn g3k_controller_trigger_haptic(self_: *mut G3kController, duration_seconds: c_float, frequency: c_float, amplitude: c_float);
    pub fn g3k_controller_update_grab(self_: *mut G3kController);
    pub fn g3k_controller_update_hovered_object(self_: *mut G3kController, last_object: *mut G3kObject, object: *mut G3kObject, global_intersection: *mut graphene::graphene_point3d_t, local_intersection: *mut graphene::graphene_point_t, intersection_distance: c_float);

    //=========================================================================
    // G3kCursor
    //=========================================================================
    pub fn g3k_cursor_get_type() -> GType;
    pub fn g3k_cursor_new(g3k: *mut G3kContext) -> *mut G3kCursor;
    pub fn g3k_cursor_set_hotspot(self_: *mut G3kCursor, hotspot_x: c_int, hotspot_y: c_int);
    pub fn g3k_cursor_update(self_: *mut G3kCursor, target: *mut G3kObject, intersection: *mut graphene::graphene_point3d_t);

    //=========================================================================
    // G3kKeyboard
    //=========================================================================
    pub fn g3k_keyboard_get_type() -> GType;
    pub fn g3k_keyboard_new(context: *mut G3kContext) -> *mut G3kKeyboard;
    pub fn g3k_keyboard_click_cb(button: *mut G3kKeyboardButton, controller: *mut gxr::GxrController, user_data: gpointer);
    pub fn g3k_keyboard_get_modes(self_: *mut G3kKeyboard) -> *mut glib::GHashTable;
    pub fn g3k_keyboard_hide(self_: *mut G3kKeyboard);
    pub fn g3k_keyboard_is_visible(self_: *mut G3kKeyboard) -> gboolean;
    pub fn g3k_keyboard_show(self_: *mut G3kKeyboard);

    //=========================================================================
    // G3kKeyboardButton
    //=========================================================================
    pub fn g3k_keyboard_button_get_type() -> GType;
    pub fn g3k_keyboard_button_new(g3k: *mut G3kContext, size_meters: *mut graphene::graphene_size_t) -> *mut G3kKeyboardButton;

    //=========================================================================
    // G3kLoader
    //=========================================================================
    pub fn g3k_loader_get_type() -> GType;
    pub fn g3k_loader_new_from_file(context: *mut G3kContext, file_path: *const c_char, error: *mut *mut glib::GError) -> *mut G3kLoader;
    pub fn g3k_loader_error_quark() -> glib::GQuark;
    pub fn g3k_loader_get_root(self_: *mut G3kLoader) -> *mut G3kObject;

    //=========================================================================
    // G3kMaterial
    //=========================================================================
    pub fn g3k_material_get_type() -> GType;
    pub fn g3k_material_new(context: *mut G3kContext) -> *mut G3kMaterial;
    pub fn g3k_material_new_default(context: *mut G3kContext) -> *mut G3kMaterial;
    pub fn g3k_material_add_texture(self_: *mut G3kMaterial, name: *const c_char, texture: *mut gulkan::GulkanTexture);
    pub fn g3k_material_create_descriptor_bindings(self_: *mut G3kMaterial, size: *mut u32) -> *mut vulkan::VkDescriptorSetLayoutBinding;
    pub fn g3k_material_get_config_key(self_: *mut G3kMaterial) -> *mut c_char;
    pub fn g3k_material_get_defines(self_: *mut G3kMaterial) -> *mut c_char;
    pub fn g3k_material_update_descriptors(self_: *mut G3kMaterial, descriptor_set: *mut gulkan::GulkanDescriptorSet);
    pub fn g3k_material_update_ubo(self_: *mut G3kMaterial);

    //=========================================================================
    // G3kMesh
    //=========================================================================
    pub fn g3k_mesh_get_type() -> GType;
    pub fn g3k_mesh_new() -> *mut G3kMesh;

    //=========================================================================
    // G3kModel
    //=========================================================================
    pub fn g3k_model_get_type() -> GType;
    pub fn g3k_model_new(g3k: *mut G3kContext) -> *mut G3kModel;
    pub fn g3k_model_get_name(self_: *mut G3kModel) -> *mut c_char;
    pub fn g3k_model_initialize(self_: *mut G3kModel, pipelines: *mut glib::GHashTable) -> bool;
    pub fn g3k_model_set_mesh(self_: *mut G3kModel, mesh: *mut G3kMesh);
    pub fn g3k_model_set_name(self_: *mut G3kModel, name: *mut c_char);

    //=========================================================================
    // G3kObject
    //=========================================================================
    pub fn g3k_object_get_type() -> GType;
    pub fn g3k_object_new() -> *mut G3kObject;
    pub fn g3k_object_add_child(self_: *mut G3kObject, child: *mut G3kObject, child_drawing_order: u32);
    pub fn g3k_object_bind(self_: *mut G3kObject, cmd_buffer: vulkan::VkCommandBuffer);
    pub fn g3k_object_draw(self_: *mut G3kObject, cmd_buffer: vulkan::VkCommandBuffer);
    pub fn g3k_object_emit_grab_start(self_: *mut G3kObject, controller: *mut G3kController);
    pub fn g3k_object_get_children(self_: *mut G3kObject) -> *mut glib::GSList;
    pub fn g3k_object_get_context(self_: *mut G3kObject) -> *mut G3kContext;
    pub fn g3k_object_get_descriptor_set(self_: *mut G3kObject) -> *mut gulkan::GulkanDescriptorSet;
    pub fn g3k_object_get_intersection(self_: *mut G3kObject, ray: *mut graphene::graphene_ray_t, distance: *mut c_float, res: *mut graphene::graphene_point3d_t) -> gboolean;
    pub fn g3k_object_get_local_matrix(self_: *mut G3kObject, m: *mut graphene::graphene_matrix_t);
    pub fn g3k_object_get_local_scale(self_: *mut G3kObject, scale: *mut graphene::graphene_point3d_t);
    pub fn g3k_object_get_matrix(self_: *mut G3kObject, m: *mut graphene::graphene_matrix_t);
    pub fn g3k_object_get_object_space_intersection(self_: *mut G3kObject, intersection_3d: *mut graphene::graphene_point3d_t, intersection_2d: *mut graphene::graphene_point_t);
    pub fn g3k_object_get_parent(self_: *mut G3kObject) -> *mut G3kObject;
    pub fn g3k_object_get_pipeline(self_: *mut G3kObject) -> *mut G3kPipeline;
    pub fn g3k_object_get_pose(self_: *mut G3kObject) -> G3kPose;
    pub fn g3k_object_get_position(self_: *mut G3kObject, position: *mut graphene::graphene_point3d_t);
    pub fn g3k_object_get_scale(self_: *mut G3kObject, out_scale: *mut graphene::graphene_point3d_t);
    pub fn g3k_object_get_transformation_ubo(self_: *mut G3kObject) -> *mut gulkan::GulkanUniformBuffer;
    pub fn g3k_object_initialize(self_: *mut G3kObject, g3k: *mut G3kContext, pipeline: *mut G3kPipeline, uniform_buffer_size: vulkan::VkDeviceSize) -> gboolean;
    pub fn g3k_object_is_visible(self_: *mut G3kObject) -> gboolean;
    pub fn g3k_object_remove_child(self_: *mut G3kObject, child: *mut G3kObject);
    pub fn g3k_object_reset_local_scale(self_: *mut G3kObject);
    pub fn g3k_object_set_local_matrix(self_: *mut G3kObject, m: *mut graphene::graphene_matrix_t);
    pub fn g3k_object_set_local_pose(self_: *mut G3kObject, pose: *mut G3kPose);
    pub fn g3k_object_set_local_scale(self_: *mut G3kObject, scale: *mut graphene::graphene_point3d_t);
    pub fn g3k_object_set_matrix(self_: *mut G3kObject, m: *mut graphene::graphene_matrix_t);
    pub fn g3k_object_set_pose(self_: *mut G3kObject, pose: *mut G3kPose);
    pub fn g3k_object_set_scale(self_: *mut G3kObject, scale: *mut graphene::graphene_point3d_t);
    pub fn g3k_object_set_visibility(self_: *mut G3kObject, is_visible: gboolean);
    pub fn g3k_object_update_selection(self_: *mut G3kObject, selection: *mut G3kSelection) -> gboolean;
    pub fn g3k_object_update_transformation_ubo(self_: *mut G3kObject, data: gpointer);

    //=========================================================================
    // G3kObjectManager
    //=========================================================================
    pub fn g3k_object_manager_get_type() -> GType;
    pub fn g3k_object_manager_new(context: *mut G3kContext) -> *mut G3kObjectManager;
    pub fn g3k_object_manager_add_container(self_: *mut G3kObjectManager, container: *mut G3kContainer);
    pub fn g3k_object_manager_add_object(self_: *mut G3kObjectManager, object: *mut G3kObject, flags: G3kInteractionFlags);
    pub fn g3k_object_manager_arrange_reset(self_: *mut G3kObjectManager);
    pub fn g3k_object_manager_arrange_sphere(self_: *mut G3kObjectManager) -> gboolean;
    pub fn g3k_object_manager_drag_start(self_: *mut G3kObjectManager, controller: *mut G3kController);
    pub fn g3k_object_manager_get_buttons(self_: *mut G3kObjectManager) -> *mut glib::GSList;
    pub fn g3k_object_manager_get_hover_mode(self_: *mut G3kObjectManager) -> G3kHoverMode;
    pub fn g3k_object_manager_get_objects(self_: *mut G3kObjectManager) -> *mut glib::GSList;
    pub fn g3k_object_manager_remove_container(self_: *mut G3kObjectManager, container: *mut G3kContainer);
    pub fn g3k_object_manager_remove_object(self_: *mut G3kObjectManager, object: *mut G3kObject);
    pub fn g3k_object_manager_save_reset_transformation(self_: *mut G3kObjectManager, object: *mut G3kObject);
    pub fn g3k_object_manager_set_hover_mode(self_: *mut G3kObjectManager, mode: G3kHoverMode);
    pub fn g3k_object_manager_step_containers(self_: *mut G3kObjectManager);
    pub fn g3k_object_manager_update_controller(self_: *mut G3kObjectManager, controller: *mut G3kController);

    //=========================================================================
    // G3kPipeline
    //=========================================================================
    pub fn g3k_pipeline_get_type() -> GType;
    pub fn g3k_pipeline_new(context: *mut G3kContext, bindings: *const vulkan::VkDescriptorSetLayoutBinding, set_size: u32, max_sets: u32, config: *mut gulkan::GulkanPipelineConfig, render_pass: *mut gulkan::GulkanRenderPass) -> *mut G3kPipeline;
    pub fn g3k_pipeline_bind(self_: *mut G3kPipeline, cmd_buffer: vulkan::VkCommandBuffer);
    pub fn g3k_pipeline_create_descriptor_set(self_: *mut G3kPipeline) -> *mut gulkan::GulkanDescriptorSet;
    pub fn g3k_pipeline_get_layout(self_: *mut G3kPipeline) -> vulkan::VkPipelineLayout;

    //=========================================================================
    // G3kPlane
    //=========================================================================
    pub fn g3k_plane_get_type() -> GType;
    pub fn g3k_plane_new() -> *mut G3kPlane;
    pub fn g3k_plane_get_content_extent(self_: *mut G3kPlane) -> vulkan::VkExtent2D;
    pub fn g3k_plane_get_global_ppm(self_: *mut G3kPlane) -> c_float;
    pub fn g3k_plane_get_global_size_meters(self_: *mut G3kPlane) -> graphene::graphene_size_t;
    pub fn g3k_plane_get_mesh_size(self_: *mut G3kPlane) -> graphene::graphene_size_t;
    pub fn g3k_plane_get_texture(self_: *mut G3kPlane) -> *mut gulkan::GulkanTexture;
    pub fn g3k_plane_get_vertex_buffer(self_: *mut G3kPlane) -> *mut gulkan::GulkanVertexBuffer;
    pub fn g3k_plane_has_texture(self_: *mut G3kPlane) -> gboolean;
    pub fn g3k_plane_set_mesh_size(self_: *mut G3kPlane, size_meters: *mut graphene::graphene_size_t);
    pub fn g3k_plane_set_texture(self_: *mut G3kPlane, texture: *mut gulkan::GulkanTexture);

    //=========================================================================
    // G3kPrimitive
    //=========================================================================
    pub fn g3k_primitive_get_type() -> GType;
    pub fn g3k_primitive_new(context: *mut G3kContext) -> *mut G3kPrimitive;
    pub fn g3k_primitive_add_attribute(self_: *mut G3kPrimitive, name: *const c_char, accessor: *mut G3kAccessor) -> bool;
    pub fn g3k_primitive_add_index(self_: *mut G3kPrimitive, accessor: *mut G3kAccessor) -> bool;
    pub fn g3k_primitive_create_attrib_desc(self_: *mut G3kPrimitive) -> *mut vulkan::VkVertexInputAttributeDescription;
    pub fn g3k_primitive_create_pipeline(self_: *mut G3kPrimitive) -> *mut G3kPipeline;
    pub fn g3k_primitive_draw(self_: *mut G3kPrimitive, descriptor_set: *mut gulkan::GulkanDescriptorSet, cmd_buffer: vulkan::VkCommandBuffer);
    pub fn g3k_primitive_get_attrib_defines(self_: *mut G3kPrimitive) -> *mut c_char;
    pub fn g3k_primitive_get_attribute_config_key(self_: *mut G3kPrimitive) -> *mut c_char;
    pub fn g3k_primitive_get_pipeline_key(self_: *mut G3kPrimitive) -> *mut c_char;
    pub fn g3k_primitive_init_vertex_buffer(self_: *mut G3kPrimitive, g3k: *mut G3kContext) -> gboolean;
    pub fn g3k_primitive_set_pipeline(self_: *mut G3kPrimitive, pipeline: *mut G3kPipeline);

    //=========================================================================
    // G3kRay
    //=========================================================================
    pub fn g3k_ray_get_type() -> GType;
    pub fn g3k_ray_new(g3k: *mut G3kContext) -> *mut G3kRay;
    pub fn g3k_ray_get_default_length(self_: *mut G3kRay) -> c_float;
    pub fn g3k_ray_get_intersection(self_: *mut G3kRay, object: *mut G3kObject, distance: *mut c_float, res: *mut graphene::graphene_point3d_t) -> gboolean;
    pub fn g3k_ray_reset_length(self_: *mut G3kRay);
    pub fn g3k_ray_set_length(self_: *mut G3kRay, length: c_float);
    pub fn g3k_ray_show(self_: *mut G3kRay);

    //=========================================================================
    // G3kRenderer
    //=========================================================================
    pub fn g3k_renderer_get_type() -> GType;
    pub fn g3k_renderer_new(context: *mut G3kContext) -> *mut G3kRenderer;
    pub fn g3k_renderer_draw(self_: *mut G3kRenderer) -> gboolean;
    pub fn g3k_renderer_get_lights_buffer(self_: *mut G3kRenderer) -> *mut gulkan::GulkanUniformBuffer;
    pub fn g3k_renderer_get_pipeline(self_: *mut G3kRenderer, name: *const c_char) -> *mut G3kPipeline;
    pub fn g3k_renderer_get_render_pass(self_: *mut G3kRenderer) -> *mut gulkan::GulkanRenderPass;
    pub fn g3k_renderer_get_sample_count(self_: *mut G3kRenderer) -> vulkan::VkSampleCountFlagBits;

    //=========================================================================
    // G3kSampler
    //=========================================================================
    pub fn g3k_sampler_get_type() -> GType;
    pub fn g3k_sampler_new() -> *mut G3kSampler;

    //=========================================================================
    // G3kSelection
    //=========================================================================
    pub fn g3k_selection_get_type() -> GType;
    pub fn g3k_selection_new(g3k: *mut G3kContext) -> *mut G3kSelection;
    pub fn g3k_selection_set_quad(self_: *mut G3kSelection, width: c_float, height: c_float);

    //=========================================================================
    // G3kTip
    //=========================================================================
    pub fn g3k_tip_get_type() -> GType;
    pub fn g3k_tip_new(g3k: *mut G3kContext) -> *mut G3kTip;
    pub fn g3k_tip_animate_pulse(self_: *mut G3kTip);
    pub fn g3k_tip_set_active(self_: *mut G3kTip, active: gboolean);
    pub fn g3k_tip_update_apparent_size(self_: *mut G3kTip);

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn g3k_attribute_type_from_component_type(component_type: i64) -> G3kAttributeType;
    pub fn g3k_attribute_type_size(type_: G3kAttributeType) -> size_t;
    pub fn g3k_attribute_type_string(type_: G3kAttributeType) -> *const c_char;
    pub fn g3k_math_clamp_towards_zero_2d(min: *mut graphene::graphene_point_t, max: *mut graphene::graphene_point_t, point: *mut graphene::graphene_point_t, clamped: *mut graphene::graphene_point_t) -> gboolean;
    pub fn g3k_math_get_rotation_angles(direction: *mut graphene::graphene_vec3_t, azimuth: *mut c_float, inclination: *mut c_float);
    pub fn g3k_math_intersect_lines_2d(p0: *mut graphene::graphene_point_t, p1: *mut graphene::graphene_point_t, p2: *mut graphene::graphene_point_t, p3: *mut graphene::graphene_point_t, intersection: *mut graphene::graphene_point_t) -> gboolean;
    pub fn g3k_math_matrix_set_translation_point(matrix: *mut graphene::graphene_matrix_t, point: *mut graphene::graphene_point3d_t);
    pub fn g3k_math_sphere_to_3d_coords(azimuth: c_float, inclination: c_float, distance: c_float, point: *mut graphene::graphene_point3d_t);
    pub fn g3k_settings_connect_and_apply(callback: gobject::GCallback, schema_id: *const c_char, key: *mut c_char, data: gpointer);
    pub fn g3k_settings_destroy();
    pub fn g3k_settings_get_instance(schema_id: *const c_char) -> *mut gio::GSettings;
    pub fn g3k_settings_is_schema_installed(schema_id: *const c_char) -> gboolean;
    pub fn g3k_settings_update_double_val(settings: *mut gio::GSettings, key: *mut c_char, val: *mut c_double);
    pub fn g3k_settings_update_gboolean_val(settings: *mut gio::GSettings, key: *mut c_char, val: *mut gboolean);
    pub fn g3k_settings_update_int_val(settings: *mut gio::GSettings, key: *mut c_char, val: *mut c_int);
    pub fn g3k_transform_lock_string(lock: G3kTransformLock) -> *const c_char;

}
