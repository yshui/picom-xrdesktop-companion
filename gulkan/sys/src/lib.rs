// Generated by gir (https://github.com/gtk-rs/gir @ 2358cc24efd2)
// from ../../gir-files (@ eab91ba8f88b)
// from ../../xrd-gir-files (@ 2f1ef32fd867)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(clippy::approx_constant, clippy::type_complexity, clippy::unreadable_literal, clippy::upper_case_acronyms)]
#![cfg_attr(feature = "dox", feature(doc_cfg))]


#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, intptr_t, uintptr_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

// Constants
pub const GULKAN_DMABUF_MAX_PLANES: c_int = 4;

// Records
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GulkanAxisEvent {
    pub axis: u32,
    pub value: i32,
}

impl ::std::fmt::Debug for GulkanAxisEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanAxisEvent @ {self:p}"))
         .field("axis", &self.axis)
         .field("value", &self.value)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GulkanBufferClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GulkanBufferClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanBufferClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GulkanButtonEvent {
    pub button: u32,
    pub is_pressed: gboolean,
}

impl ::std::fmt::Debug for GulkanButtonEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanButtonEvent @ {self:p}"))
         .field("button", &self.button)
         .field("is_pressed", &self.is_pressed)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GulkanCmdBufferClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GulkanCmdBufferClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanCmdBufferClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct GulkanConfigureEvent {
    _truncated_record_marker: c_void,
    // /*Ignored*/field extent has incomplete type
}

impl ::std::fmt::Debug for GulkanConfigureEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanConfigureEvent @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GulkanContextClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GulkanContextClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanContextClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GulkanDescriptorPoolClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GulkanDescriptorPoolClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanDescriptorPoolClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GulkanDescriptorSetClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GulkanDescriptorSetClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanDescriptorSetClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GulkanDeviceClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GulkanDeviceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanDeviceClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GulkanDmabufAttributes {
    pub width: i32,
    pub height: i32,
    pub format: u32,
    pub modifier: u64,
    pub n_planes: c_int,
    pub offset: [u32; 4],
    pub stride: [u32; 4],
    pub fd: [c_int; 4],
}

impl ::std::fmt::Debug for GulkanDmabufAttributes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanDmabufAttributes @ {self:p}"))
         .field("width", &self.width)
         .field("height", &self.height)
         .field("format", &self.format)
         .field("modifier", &self.modifier)
         .field("n_planes", &self.n_planes)
         .field("offset", &self.offset)
         .field("stride", &self.stride)
         .field("fd", &self.fd)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GulkanFrameBufferClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GulkanFrameBufferClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanFrameBufferClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GulkanInstanceClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GulkanInstanceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanInstanceClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GulkanKeyEvent {
    pub key: u32,
    pub is_pressed: gboolean,
}

impl ::std::fmt::Debug for GulkanKeyEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanKeyEvent @ {self:p}"))
         .field("key", &self.key)
         .field("is_pressed", &self.is_pressed)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GulkanPipelineClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GulkanPipelineClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanPipelineClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
pub struct GulkanPipelineConfig {
    _truncated_record_marker: c_void,
    // /*Ignored*/field extent has incomplete type
}

impl ::std::fmt::Debug for GulkanPipelineConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanPipelineConfig @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct GulkanPositionEvent {
    _truncated_record_marker: c_void,
    // /*Ignored*/field offset has incomplete type
}

impl ::std::fmt::Debug for GulkanPositionEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanPositionEvent @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GulkanQueueClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GulkanQueueClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanQueueClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GulkanRenderPassClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GulkanRenderPassClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanRenderPassClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GulkanRendererClass {
    pub parent: gobject::GObjectClass,
    pub draw: Option<unsafe extern "C" fn(*mut GulkanRenderer) -> gboolean>,
}

impl ::std::fmt::Debug for GulkanRendererClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanRendererClass @ {self:p}"))
         .field("parent", &self.parent)
         .field("draw", &self.draw)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GulkanSwapchainClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GulkanSwapchainClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanSwapchainClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GulkanSwapchainRendererClass {
    pub parent: GulkanRendererClass,
    pub init_draw_cmd: Option<unsafe extern "C" fn(*mut GulkanSwapchainRenderer, vulkan::VkCommandBuffer)>,
    pub init_pipeline: Option<unsafe extern "C" fn(*mut GulkanSwapchainRenderer, gconstpointer) -> gboolean>,
}

impl ::std::fmt::Debug for GulkanSwapchainRendererClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanSwapchainRendererClass @ {self:p}"))
         .field("parent", &self.parent)
         .field("init_draw_cmd", &self.init_draw_cmd)
         .field("init_pipeline", &self.init_pipeline)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GulkanTextureClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GulkanTextureClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanTextureClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GulkanUniformBufferClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GulkanUniformBufferClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanUniformBufferClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GulkanVertexBufferClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GulkanVertexBufferClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanVertexBufferClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GulkanWindowClass {
    pub parent: gobject::GObjectClass,
    pub initialize: Option<unsafe extern "C" fn(*mut GulkanWindow, vulkan::VkExtent2D, *const c_char) -> gboolean>,
    pub create_surface: Option<unsafe extern "C" fn(*mut GulkanWindow, vulkan::VkInstance, *mut vulkan::VkSurfaceKHR) -> vulkan::VkResult>,
    pub required_extensions: Option<unsafe extern "C" fn() -> *mut glib::GSList>,
    pub poll_events: Option<unsafe extern "C" fn(*mut GulkanWindow)>,
    pub toggle_fullscreen: Option<unsafe extern "C" fn(*mut GulkanWindow)>,
    pub has_support: Option<unsafe extern "C" fn(*mut GulkanWindow, *mut GulkanContext) -> gboolean>,
    pub can_run: Option<unsafe extern "C" fn(*mut GulkanWindow) -> gboolean>,
}

impl ::std::fmt::Debug for GulkanWindowClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanWindowClass @ {self:p}"))
         .field("parent", &self.parent)
         .field("initialize", &self.initialize)
         .field("create_surface", &self.create_surface)
         .field("required_extensions", &self.required_extensions)
         .field("poll_events", &self.poll_events)
         .field("toggle_fullscreen", &self.toggle_fullscreen)
         .field("has_support", &self.has_support)
         .field("can_run", &self.can_run)
         .finish()
    }
}

// Classes
#[repr(C)]
pub struct GulkanBuffer {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GulkanBuffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanBuffer @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct GulkanCmdBuffer {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GulkanCmdBuffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanCmdBuffer @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GulkanContext {
    pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for GulkanContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanContext @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
pub struct GulkanDescriptorPool {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GulkanDescriptorPool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanDescriptorPool @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct GulkanDescriptorSet {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GulkanDescriptorSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanDescriptorSet @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct GulkanDevice {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GulkanDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanDevice @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct GulkanFrameBuffer {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GulkanFrameBuffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanFrameBuffer @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct GulkanInstance {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GulkanInstance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanInstance @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct GulkanPipeline {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GulkanPipeline {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanPipeline @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct GulkanQueue {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GulkanQueue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanQueue @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct GulkanRenderPass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GulkanRenderPass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanRenderPass @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GulkanRenderer {
    pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for GulkanRenderer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanRenderer @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
pub struct GulkanSwapchain {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GulkanSwapchain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanSwapchain @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GulkanSwapchainRenderer {
    pub parent_instance: GulkanRenderer,
}

impl ::std::fmt::Debug for GulkanSwapchainRenderer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanSwapchainRenderer @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
pub struct GulkanTexture {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GulkanTexture {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanTexture @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct GulkanUniformBuffer {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GulkanUniformBuffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanUniformBuffer @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct GulkanVertexBuffer {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GulkanVertexBuffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanVertexBuffer @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GulkanWindow {
    pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for GulkanWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GulkanWindow @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[link(name = "gulkan-0.16")]
extern "C" {

    //=========================================================================
    // GulkanBuffer
    //=========================================================================
    pub fn gulkan_buffer_get_type() -> GType;
    pub fn gulkan_buffer_new(device: *mut GulkanDevice, size: vulkan::VkDeviceSize, usage: vulkan::VkBufferUsageFlags, properties: vulkan::VkMemoryPropertyFlags) -> *mut GulkanBuffer;
    pub fn gulkan_buffer_new_from_data(device: *mut GulkanDevice, data: *mut c_void, size: vulkan::VkDeviceSize, usage: vulkan::VkBufferUsageFlags, properties: vulkan::VkMemoryPropertyFlags) -> *mut GulkanBuffer;
    pub fn gulkan_buffer_get_handle(self_: *mut GulkanBuffer) -> vulkan::VkBuffer;
    pub fn gulkan_buffer_get_memory_handle(self_: *mut GulkanBuffer) -> vulkan::VkDeviceMemory;
    pub fn gulkan_buffer_map(self_: *mut GulkanBuffer, data: *mut *mut c_void) -> gboolean;
    pub fn gulkan_buffer_unmap(self_: *mut GulkanBuffer);
    pub fn gulkan_buffer_upload(self_: *mut GulkanBuffer, data: *mut c_void, size: vulkan::VkDeviceSize) -> gboolean;

    //=========================================================================
    // GulkanCmdBuffer
    //=========================================================================
    pub fn gulkan_cmd_buffer_get_type() -> GType;
    pub fn gulkan_cmd_buffer_begin(self_: *mut GulkanCmdBuffer, flags: vulkan::VkCommandBufferUsageFlags) -> gboolean;
    pub fn gulkan_cmd_buffer_begin_one_time(self_: *mut GulkanCmdBuffer) -> gboolean;
    pub fn gulkan_cmd_buffer_end(self_: *mut GulkanCmdBuffer) -> gboolean;
    pub fn gulkan_cmd_buffer_get_handle(self_: *mut GulkanCmdBuffer) -> vulkan::VkCommandBuffer;

    //=========================================================================
    // GulkanContext
    //=========================================================================
    pub fn gulkan_context_get_type() -> GType;
    pub fn gulkan_context_new() -> *mut GulkanContext;
    pub fn gulkan_context_new_from_extensions(instance_ext_list: *mut glib::GSList, device_ext_list: *mut glib::GSList, physical_device: vulkan::VkPhysicalDevice) -> *mut GulkanContext;
    pub fn gulkan_context_new_from_instance(instance: *mut GulkanInstance, device_ext_list: *mut glib::GSList, physical_device: vulkan::VkPhysicalDevice) -> *mut GulkanContext;
    pub fn gulkan_context_new_from_vk(vk_instance: vulkan::VkInstance, vk_physical_device: vulkan::VkPhysicalDevice, vk_device: vulkan::VkDevice, graphics_queue_index: u32, transfer_queue_index: u32) -> *mut GulkanContext;
    pub fn gulkan_context_get_external_memory_device_extensions() -> *mut glib::GSList;
    pub fn gulkan_context_get_external_memory_instance_extensions() -> *mut glib::GSList;
    pub fn gulkan_context_get_device(self_: *mut GulkanContext) -> *mut GulkanDevice;
    pub fn gulkan_context_get_device_handle(self_: *mut GulkanContext) -> vulkan::VkDevice;
    pub fn gulkan_context_get_instance(self_: *mut GulkanContext) -> *mut GulkanInstance;
    pub fn gulkan_context_get_instance_handle(self_: *mut GulkanContext) -> vulkan::VkInstance;
    pub fn gulkan_context_get_physical_device_handle(self_: *mut GulkanContext) -> vulkan::VkPhysicalDevice;

    //=========================================================================
    // GulkanDescriptorPool
    //=========================================================================
    pub fn gulkan_descriptor_pool_get_type() -> GType;
    pub fn gulkan_descriptor_pool_new(context: *mut GulkanContext, bindings: *const vulkan::VkDescriptorSetLayoutBinding, set_size: u32, max_sets: u32) -> *mut GulkanDescriptorPool;
    pub fn gulkan_descriptor_pool_create_set(self_: *mut GulkanDescriptorPool) -> *mut GulkanDescriptorSet;
    pub fn gulkan_descriptor_pool_get_pipeline_layout(self_: *mut GulkanDescriptorPool) -> vulkan::VkPipelineLayout;

    //=========================================================================
    // GulkanDescriptorSet
    //=========================================================================
    pub fn gulkan_descriptor_set_get_type() -> GType;
    pub fn gulkan_descriptor_set_new(context: *mut GulkanContext, handle: vulkan::VkDescriptorSet, pool: vulkan::VkDescriptorPool, size: u32) -> *mut GulkanDescriptorSet;
    pub fn gulkan_descriptor_set_bind(self_: *mut GulkanDescriptorSet, layout: vulkan::VkPipelineLayout, cmd_buffer: vulkan::VkCommandBuffer);
    pub fn gulkan_descriptor_set_update_buffer(self_: *mut GulkanDescriptorSet, index: c_uint, buffer: *mut GulkanUniformBuffer);
    pub fn gulkan_descriptor_set_update_buffer_at(self_: *mut GulkanDescriptorSet, index: c_uint, binding: c_uint, buffer: *mut GulkanUniformBuffer);
    pub fn gulkan_descriptor_set_update_texture(self_: *mut GulkanDescriptorSet, index: c_uint, texture: *mut GulkanTexture);
    pub fn gulkan_descriptor_set_update_texture_at(self_: *mut GulkanDescriptorSet, index: c_uint, binding: c_uint, texture: *mut GulkanTexture);
    pub fn gulkan_descriptor_set_update_view_sampler(self_: *mut GulkanDescriptorSet, index: c_uint, view: vulkan::VkImageView, sampler: vulkan::VkSampler);

    //=========================================================================
    // GulkanDevice
    //=========================================================================
    pub fn gulkan_device_get_type() -> GType;
    pub fn gulkan_device_new() -> *mut GulkanDevice;
    pub fn gulkan_device_create(self_: *mut GulkanDevice, instance: *mut GulkanInstance, device: vulkan::VkPhysicalDevice, extensions: *mut glib::GSList) -> gboolean;
    pub fn gulkan_device_create_from_vk(self_: *mut GulkanDevice, vk_physical_device: vulkan::VkPhysicalDevice, vk_device: vulkan::VkDevice, graphics_queue_index: u32, transfer_queue_index: u32) -> gboolean;
    pub fn gulkan_device_create_shader_module(self_: *mut GulkanDevice, resource_name: *const c_char, module: *mut vulkan::VkShaderModule) -> gboolean;
    pub fn gulkan_device_get_graphics_queue(self_: *mut GulkanDevice) -> *mut GulkanQueue;
    pub fn gulkan_device_get_handle(self_: *mut GulkanDevice) -> vulkan::VkDevice;
    pub fn gulkan_device_get_heap_budget(self_: *mut GulkanDevice, i: u32) -> vulkan::VkDeviceSize;
    pub fn gulkan_device_get_memory_fd(self_: *mut GulkanDevice, image_memory: vulkan::VkDeviceMemory, fd: *mut c_int) -> gboolean;
    pub fn gulkan_device_get_physical_device_properties(self_: *mut GulkanDevice) -> *mut vulkan::VkPhysicalDeviceProperties;
    pub fn gulkan_device_get_physical_handle(self_: *mut GulkanDevice) -> vulkan::VkPhysicalDevice;
    pub fn gulkan_device_get_transfer_queue(self_: *mut GulkanDevice) -> *mut GulkanQueue;
    pub fn gulkan_device_memory_type_from_properties(self_: *mut GulkanDevice, memory_type_bits: u32, memory_property_flags: vulkan::VkMemoryPropertyFlags, type_index_out: *mut u32) -> gboolean;
    pub fn gulkan_device_print_memory_budget(self_: *mut GulkanDevice);
    pub fn gulkan_device_print_memory_properties(self_: *mut GulkanDevice);
    pub fn gulkan_device_wait_idle(self_: *mut GulkanDevice);

    //=========================================================================
    // GulkanFrameBuffer
    //=========================================================================
    pub fn gulkan_frame_buffer_get_type() -> GType;
    pub fn gulkan_frame_buffer_new(device: *mut GulkanDevice, render_pass: *mut GulkanRenderPass, extent: vulkan::VkExtent2D, sample_count: vulkan::VkSampleCountFlagBits, color_format: vulkan::VkFormat, use_depth: gboolean, layer_count: u32) -> *mut GulkanFrameBuffer;
    pub fn gulkan_frame_buffer_new_from_image(device: *mut GulkanDevice, render_pass: *mut GulkanRenderPass, color_image: vulkan::VkImage, extent: vulkan::VkExtent2D, color_format: vulkan::VkFormat, layer_count: u32) -> *mut GulkanFrameBuffer;
    pub fn gulkan_frame_buffer_new_from_image_with_depth(device: *mut GulkanDevice, render_pass: *mut GulkanRenderPass, color_image: vulkan::VkImage, extent: vulkan::VkExtent2D, sample_count: vulkan::VkSampleCountFlagBits, color_format: vulkan::VkFormat, layer_count: u32) -> *mut GulkanFrameBuffer;
    pub fn gulkan_frame_buffer_get_color_image(self_: *mut GulkanFrameBuffer) -> vulkan::VkImage;
    pub fn gulkan_frame_buffer_get_handle(self_: *mut GulkanFrameBuffer) -> vulkan::VkFramebuffer;

    //=========================================================================
    // GulkanInstance
    //=========================================================================
    pub fn gulkan_instance_get_type() -> GType;
    pub fn gulkan_instance_new() -> *mut GulkanInstance;
    pub fn gulkan_instance_create(self_: *mut GulkanInstance, required_extensions: *mut glib::GSList) -> gboolean;
    pub fn gulkan_instance_create_from_vk(self_: *mut GulkanInstance, vk_instance: vulkan::VkInstance) -> gboolean;
    pub fn gulkan_instance_get_handle(self_: *mut GulkanInstance) -> vulkan::VkInstance;

    //=========================================================================
    // GulkanPipeline
    //=========================================================================
    pub fn gulkan_pipeline_get_type() -> GType;
    pub fn gulkan_pipeline_new(context: *mut GulkanContext, descriptor_pool: *mut GulkanDescriptorPool, render_pass: *mut GulkanRenderPass, config: *mut GulkanPipelineConfig) -> *mut GulkanPipeline;
    pub fn gulkan_pipeline_bind(self_: *mut GulkanPipeline, cmd_buffer: vulkan::VkCommandBuffer);

    //=========================================================================
    // GulkanQueue
    //=========================================================================
    pub fn gulkan_queue_get_type() -> GType;
    pub fn gulkan_queue_new(device: *mut GulkanDevice, family_index: u32) -> *mut GulkanQueue;
    pub fn gulkan_queue_end_submit(self_: *mut GulkanQueue, cmd_buffer: *mut GulkanCmdBuffer) -> gboolean;
    pub fn gulkan_queue_free_cmd_buffer(self_: *mut GulkanQueue, cmd_buffer: *mut GulkanCmdBuffer);
    pub fn gulkan_queue_get_command_pool(self_: *mut GulkanQueue) -> vulkan::VkCommandPool;
    pub fn gulkan_queue_get_family_index(self_: *mut GulkanQueue) -> u32;
    pub fn gulkan_queue_get_handle(self_: *mut GulkanQueue) -> vulkan::VkQueue;
    pub fn gulkan_queue_get_pool_mutex(self_: *mut GulkanQueue) -> *mut glib::GMutex;
    pub fn gulkan_queue_initialize(self_: *mut GulkanQueue) -> gboolean;
    pub fn gulkan_queue_request_cmd_buffer(self_: *mut GulkanQueue) -> *mut GulkanCmdBuffer;
    pub fn gulkan_queue_submit(self_: *mut GulkanQueue, cmd_buffer: *mut GulkanCmdBuffer) -> gboolean;
    pub fn gulkan_queue_supports_surface(self_: *mut GulkanQueue, surface: vulkan::VkSurfaceKHR) -> gboolean;

    //=========================================================================
    // GulkanRenderPass
    //=========================================================================
    pub fn gulkan_render_pass_get_type() -> GType;
    pub fn gulkan_render_pass_new(device: *mut GulkanDevice, samples: vulkan::VkSampleCountFlagBits, color_format: vulkan::VkFormat, final_color_layout: vulkan::VkImageLayout, use_depth: gboolean) -> *mut GulkanRenderPass;
    pub fn gulkan_render_pass_new_multiview(device: *mut GulkanDevice, samples: vulkan::VkSampleCountFlagBits, color_format: vulkan::VkFormat, final_color_layout: vulkan::VkImageLayout, use_depth: gboolean) -> *mut GulkanRenderPass;
    pub fn gulkan_render_pass_begin(self_: *mut GulkanRenderPass, extent: vulkan::VkExtent2D, clear_color: vulkan::VkClearColorValue, frame_buffer: *mut GulkanFrameBuffer, cmd_buffer: vulkan::VkCommandBuffer);
    pub fn gulkan_render_pass_get_handle(self_: *mut GulkanRenderPass) -> vulkan::VkRenderPass;

    //=========================================================================
    // GulkanRenderer
    //=========================================================================
    pub fn gulkan_renderer_get_type() -> GType;
    pub fn gulkan_renderer_draw(self_: *mut GulkanRenderer) -> gboolean;
    pub fn gulkan_renderer_get_aspect(self_: *mut GulkanRenderer) -> c_float;
    pub fn gulkan_renderer_get_context(self_: *mut GulkanRenderer) -> *mut GulkanContext;
    pub fn gulkan_renderer_get_extent(self_: *mut GulkanRenderer) -> vulkan::VkExtent2D;
    pub fn gulkan_renderer_get_msec_since_start(self_: *mut GulkanRenderer) -> i64;
    pub fn gulkan_renderer_set_context(self_: *mut GulkanRenderer, context: *mut GulkanContext);
    pub fn gulkan_renderer_set_extent(self_: *mut GulkanRenderer, extent: vulkan::VkExtent2D);

    //=========================================================================
    // GulkanSwapchain
    //=========================================================================
    pub fn gulkan_swapchain_get_type() -> GType;
    pub fn gulkan_swapchain_new(context: *mut GulkanContext, surface: vulkan::VkSurfaceKHR, extent: vulkan::VkExtent2D, present_mode: vulkan::VkPresentModeKHR, format: vulkan::VkFormat, colorspace: vulkan::VkColorSpaceKHR) -> *mut GulkanSwapchain;
    pub fn gulkan_swapchain_acquire(self_: *mut GulkanSwapchain, signal_semaphore: vulkan::VkSemaphore, index: *mut u32) -> gboolean;
    pub fn gulkan_swapchain_get_extent(self_: *mut GulkanSwapchain) -> vulkan::VkExtent2D;
    pub fn gulkan_swapchain_get_format(self_: *mut GulkanSwapchain) -> vulkan::VkFormat;
    pub fn gulkan_swapchain_get_images(self_: *mut GulkanSwapchain, swap_chain_images: *mut vulkan::VkImage);
    pub fn gulkan_swapchain_get_size(self_: *mut GulkanSwapchain) -> u32;
    pub fn gulkan_swapchain_present(self_: *mut GulkanSwapchain, wait_semaphore: *mut vulkan::VkSemaphore, index: u32) -> gboolean;
    pub fn gulkan_swapchain_reset_surface(self_: *mut GulkanSwapchain, surface: vulkan::VkSurfaceKHR, extent: vulkan::VkExtent2D) -> gboolean;

    //=========================================================================
    // GulkanSwapchainRenderer
    //=========================================================================
    pub fn gulkan_swapchain_renderer_get_type() -> GType;
    pub fn gulkan_swapchain_renderer_get_render_pass(self_: *mut GulkanSwapchainRenderer) -> *mut GulkanRenderPass;
    pub fn gulkan_swapchain_renderer_init_draw_cmd_buffers(self_: *mut GulkanSwapchainRenderer) -> gboolean;
    pub fn gulkan_swapchain_renderer_initialize(self_: *mut GulkanSwapchainRenderer, clear_color: vulkan::VkClearColorValue, pipeline_data: gconstpointer);
    pub fn gulkan_swapchain_renderer_resize(self_: *mut GulkanSwapchainRenderer, surface: vulkan::VkSurfaceKHR, extent: vulkan::VkExtent2D) -> gboolean;

    //=========================================================================
    // GulkanTexture
    //=========================================================================
    pub fn gulkan_texture_get_type() -> GType;
    pub fn gulkan_texture_new(context: *mut GulkanContext, extent: vulkan::VkExtent2D, format: vulkan::VkFormat) -> *mut GulkanTexture;
    pub fn gulkan_texture_new_export_fd(context: *mut GulkanContext, extent: vulkan::VkExtent2D, format: vulkan::VkFormat, layout: vulkan::VkImageLayout, size: *mut size_t, fd: *mut c_int) -> *mut GulkanTexture;
    pub fn gulkan_texture_new_from_cairo_surface(context: *mut GulkanContext, surface: *mut cairo::cairo_surface_t, format: vulkan::VkFormat, layout: vulkan::VkImageLayout) -> *mut GulkanTexture;
    pub fn gulkan_texture_new_from_dmabuf(context: *mut GulkanContext, fd: c_int, extent: vulkan::VkExtent2D, format: vulkan::VkFormat) -> *mut GulkanTexture;
    pub fn gulkan_texture_new_from_dmabuf_attribs(context: *mut GulkanContext, attribs: *mut GulkanDmabufAttributes) -> *mut GulkanTexture;
    pub fn gulkan_texture_new_from_pixbuf(context: *mut GulkanContext, pixbuf: *mut gdk_pixbuf::GdkPixbuf, format: vulkan::VkFormat, layout: vulkan::VkImageLayout, create_mipmaps: gboolean) -> *mut GulkanTexture;
    pub fn gulkan_texture_new_from_resource(context: *mut GulkanContext, resource_path: *const c_char, layout: vulkan::VkImageLayout, create_mipmaps: gboolean) -> *mut GulkanTexture;
    pub fn gulkan_texture_new_mip_levels(context: *mut GulkanContext, extent: vulkan::VkExtent2D, mip_levels: c_uint, format: vulkan::VkFormat) -> *mut GulkanTexture;
    pub fn gulkan_texture_get_descriptor_info(self_: *mut GulkanTexture) -> *mut vulkan::VkDescriptorImageInfo;
    pub fn gulkan_texture_get_extent(self_: *mut GulkanTexture) -> vulkan::VkExtent2D;
    pub fn gulkan_texture_get_format(self_: *mut GulkanTexture) -> vulkan::VkFormat;
    pub fn gulkan_texture_get_image(self_: *mut GulkanTexture) -> vulkan::VkImage;
    pub fn gulkan_texture_get_image_view(self_: *mut GulkanTexture) -> vulkan::VkImageView;
    pub fn gulkan_texture_get_mip_levels(self_: *mut GulkanTexture) -> c_uint;
    pub fn gulkan_texture_get_sampler(self_: *mut GulkanTexture) -> vulkan::VkSampler;
    pub fn gulkan_texture_init_sampler(self_: *mut GulkanTexture, filter: vulkan::VkFilter, address_mode: vulkan::VkSamplerAddressMode) -> gboolean;
    pub fn gulkan_texture_record_transfer(self_: *mut GulkanTexture, cmd_buffer: vulkan::VkCommandBuffer, src_layout: vulkan::VkImageLayout, dst_layout: vulkan::VkImageLayout);
    pub fn gulkan_texture_record_transfer_full(self_: *mut GulkanTexture, cmd_buffer: vulkan::VkCommandBuffer, src_access_mask: vulkan::VkAccessFlags, dst_access_mask: vulkan::VkAccessFlags, src_layout: vulkan::VkImageLayout, dst_layout: vulkan::VkImageLayout, src_stage_mask: vulkan::VkPipelineStageFlags, dst_stage_mask: vulkan::VkPipelineStageFlags);
    pub fn gulkan_texture_set_sampler(self_: *mut GulkanTexture, sampler: vulkan::VkSampler);
    pub fn gulkan_texture_transfer_layout(self_: *mut GulkanTexture, src_layout: vulkan::VkImageLayout, dst_layout: vulkan::VkImageLayout) -> gboolean;
    pub fn gulkan_texture_transfer_layout_full(self_: *mut GulkanTexture, src_access_mask: vulkan::VkAccessFlags, dst_access_mask: vulkan::VkAccessFlags, src_layout: vulkan::VkImageLayout, dst_layout: vulkan::VkImageLayout, src_stage_mask: vulkan::VkPipelineStageFlags, dst_stage_mask: vulkan::VkPipelineStageFlags) -> gboolean;
    pub fn gulkan_texture_upload_cairo_surface(self_: *mut GulkanTexture, surface: *mut cairo::cairo_surface_t, layout: vulkan::VkImageLayout) -> gboolean;
    pub fn gulkan_texture_upload_pixbuf(self_: *mut GulkanTexture, pixbuf: *mut gdk_pixbuf::GdkPixbuf, layout: vulkan::VkImageLayout) -> gboolean;
    pub fn gulkan_texture_upload_pixels(self_: *mut GulkanTexture, pixels: *mut u8, size: size_t, layout: vulkan::VkImageLayout) -> gboolean;
    pub fn gulkan_texture_upload_pixels_region(self_: *mut GulkanTexture, region_pixels: *mut u8, region_size: size_t, layout: vulkan::VkImageLayout, offset: vulkan::VkOffset2D, extent: vulkan::VkExtent2D) -> gboolean;

    //=========================================================================
    // GulkanUniformBuffer
    //=========================================================================
    pub fn gulkan_uniform_buffer_get_type() -> GType;
    pub fn gulkan_uniform_buffer_new(device: *mut GulkanDevice, size: vulkan::VkDeviceSize) -> *mut GulkanUniformBuffer;
    pub fn gulkan_uniform_buffer_get_descriptor_info(self_: *mut GulkanUniformBuffer) -> *mut vulkan::VkDescriptorBufferInfo;
    pub fn gulkan_uniform_buffer_get_handle(self_: *mut GulkanUniformBuffer) -> vulkan::VkBuffer;
    pub fn gulkan_uniform_buffer_update(self_: *mut GulkanUniformBuffer, s: *mut gpointer);

    //=========================================================================
    // GulkanVertexBuffer
    //=========================================================================
    pub fn gulkan_vertex_buffer_get_type() -> GType;
    pub fn gulkan_vertex_buffer_new(device: *mut GulkanDevice, topology: vulkan::VkPrimitiveTopology) -> *mut GulkanVertexBuffer;
    pub fn gulkan_vertex_buffer_get_index_type_size(type_: vulkan::VkIndexType) -> vulkan::VkDeviceSize;
    pub fn gulkan_vertex_buffer_add_attribute(self_: *mut GulkanVertexBuffer, stride: size_t, size: size_t, offset: size_t, bytes: *const u8);
    pub fn gulkan_vertex_buffer_alloc_array(self_: *mut GulkanVertexBuffer) -> gboolean;
    pub fn gulkan_vertex_buffer_alloc_data(self_: *mut GulkanVertexBuffer, data: *mut c_void, size: vulkan::VkDeviceSize) -> gboolean;
    pub fn gulkan_vertex_buffer_alloc_empty(self_: *mut GulkanVertexBuffer, multiplier: u32) -> gboolean;
    pub fn gulkan_vertex_buffer_alloc_index_data(self_: *mut GulkanVertexBuffer, data: *mut c_void, type_: vulkan::VkIndexType, element_count: size_t) -> gboolean;
    pub fn gulkan_vertex_buffer_append_position_uv(self_: *mut GulkanVertexBuffer, vec: *mut graphene::graphene_vec4_t, u: c_float, v: c_float);
    pub fn gulkan_vertex_buffer_append_with_color(self_: *mut GulkanVertexBuffer, vec: *mut graphene::graphene_vec4_t, color: *mut graphene::graphene_vec3_t);
    pub fn gulkan_vertex_buffer_bind_with_offsets(self_: *mut GulkanVertexBuffer, cmd_buffer: vulkan::VkCommandBuffer);
    pub fn gulkan_vertex_buffer_create_attrib_desc(self_: *mut GulkanVertexBuffer) -> *mut vulkan::VkVertexInputAttributeDescription;
    pub fn gulkan_vertex_buffer_create_binding_desc(self_: *mut GulkanVertexBuffer) -> *mut vulkan::VkVertexInputBindingDescription;
    pub fn gulkan_vertex_buffer_draw(self_: *mut GulkanVertexBuffer, cmd_buffer: vulkan::VkCommandBuffer);
    pub fn gulkan_vertex_buffer_draw_indexed(self_: *mut GulkanVertexBuffer, cmd_buffer: vulkan::VkCommandBuffer);
    pub fn gulkan_vertex_buffer_get_attrib_count(self_: *mut GulkanVertexBuffer) -> u32;
    pub fn gulkan_vertex_buffer_get_index_buffer(self_: *mut GulkanVertexBuffer) -> *mut GulkanBuffer;
    pub fn gulkan_vertex_buffer_get_topology(self_: *mut GulkanVertexBuffer) -> vulkan::VkPrimitiveTopology;
    pub fn gulkan_vertex_buffer_is_initialized(self_: *mut GulkanVertexBuffer) -> gboolean;
    pub fn gulkan_vertex_buffer_map_array(self_: *mut GulkanVertexBuffer) -> gboolean;
    pub fn gulkan_vertex_buffer_reset(self_: *mut GulkanVertexBuffer);
    pub fn gulkan_vertex_buffer_upload(self_: *mut GulkanVertexBuffer) -> gboolean;

    //=========================================================================
    // GulkanWindow
    //=========================================================================
    pub fn gulkan_window_get_type() -> GType;
    pub fn gulkan_window_new(extent: vulkan::VkExtent2D, title: *const c_char) -> *mut GulkanWindow;
    pub fn gulkan_window_can_run(self_: *mut GulkanWindow) -> gboolean;
    pub fn gulkan_window_create_surface(self_: *mut GulkanWindow, instance: vulkan::VkInstance, surface: *mut vulkan::VkSurfaceKHR) -> vulkan::VkResult;
    pub fn gulkan_window_has_support(self_: *mut GulkanWindow, context: *mut GulkanContext) -> gboolean;
    pub fn gulkan_window_poll_events(self_: *mut GulkanWindow);
    pub fn gulkan_window_required_extensions(self_: *mut GulkanWindow) -> *mut glib::GSList;
    pub fn gulkan_window_toggle_fullscreen(self_: *mut GulkanWindow);

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn gulkan_geometry_append_axes(self_: *mut GulkanVertexBuffer, center: *mut graphene::graphene_vec4_t, length: c_float, mat: *mut graphene::graphene_matrix_t);
    pub fn gulkan_geometry_append_plane(self_: *mut GulkanVertexBuffer, from: *mut graphene::graphene_point_t, to: *mut graphene::graphene_point_t, mat: *mut graphene::graphene_matrix_t);
    pub fn gulkan_geometry_append_ray(self_: *mut GulkanVertexBuffer, center: *mut graphene::graphene_vec4_t, length: c_float, mat: *mut graphene::graphene_matrix_t);
    pub fn gulkan_has_error(res: vulkan::VkResult, fun: *const c_char, file: *const c_char, line: c_int) -> gboolean;

}
