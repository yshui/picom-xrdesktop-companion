// Generated by gir (https://github.com/gtk-rs/gir @ 2358cc24efd2)
// from ../../gir-files (@ eab91ba8f88b)
// from ../../xrd-gir-files (@ 2f1ef32fd867)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(clippy::approx_constant, clippy::type_complexity, clippy::unreadable_literal, clippy::upper_case_acronyms)]
#![cfg_attr(feature = "dox", feature(doc_cfg))]


#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, intptr_t, uintptr_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

// Enums
pub type GxrActionType = c_int;
pub const GXR_ACTION_DIGITAL: GxrActionType = 0;
pub const GXR_ACTION_DIGITAL_FROM_FLOAT: GxrActionType = 1;
pub const GXR_ACTION_VEC2F: GxrActionType = 2;
pub const GXR_ACTION_FLOAT: GxrActionType = 3;
pub const GXR_ACTION_POSE: GxrActionType = 4;
pub const GXR_ACTION_HAPTIC: GxrActionType = 5;

pub type GxrBindingComponent = c_int;
pub const GXR_BINDING_COMPONENT_NONE: GxrBindingComponent = 0;
pub const GXR_BINDING_COMPONENT_UNKNOWN: GxrBindingComponent = 1;
pub const GXR_BINDING_COMPONENT_CLICK: GxrBindingComponent = 2;
pub const GXR_BINDING_COMPONENT_PULL: GxrBindingComponent = 3;
pub const GXR_BINDING_COMPONENT_POSITION: GxrBindingComponent = 4;
pub const GXR_BINDING_COMPONENT_TOUCH: GxrBindingComponent = 5;
pub const GXR_BINDING_COMPONENT_FORCE: GxrBindingComponent = 6;

pub type GxrBindingMode = c_int;
pub const GXR_BINDING_MODE_NONE: GxrBindingMode = 0;
pub const GXR_BINDING_MODE_UNKNOWN: GxrBindingMode = 1;
pub const GXR_BINDING_MODE_BUTTON: GxrBindingMode = 2;
pub const GXR_BINDING_MODE_TRACKPAD: GxrBindingMode = 3;
pub const GXR_BINDING_MODE_ANALOG_STICK: GxrBindingMode = 4;

pub type GxrBindingType = c_int;
pub const GXR_BINDING_TYPE_UNKNOWN: GxrBindingType = 0;
pub const GXR_BINDING_TYPE_POSE: GxrBindingType = 1;
pub const GXR_BINDING_TYPE_BOOLEAN: GxrBindingType = 2;
pub const GXR_BINDING_TYPE_FLOAT: GxrBindingType = 3;
pub const GXR_BINDING_TYPE_VEC2: GxrBindingType = 4;
pub const GXR_BINDING_TYPE_HAPTIC: GxrBindingType = 5;

pub type GxrEye = c_int;
pub const GXR_EYE_LEFT: GxrEye = 0;
pub const GXR_EYE_RIGHT: GxrEye = 1;

pub type GxrStateChange = c_int;
pub const GXR_STATE_FRAMECYCLE_START: GxrStateChange = 0;
pub const GXR_STATE_FRAMECYCLE_STOP: GxrStateChange = 1;
pub const GXR_STATE_RENDERING_START: GxrStateChange = 2;
pub const GXR_STATE_RENDERING_STOP: GxrStateChange = 3;
pub const GXR_STATE_SHUTDOWN: GxrStateChange = 4;

// Constants
pub const GXR_DEVICE_INDEX_MAX: c_int = 64;

// Records
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrActionClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GxrActionClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrActionClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrActionManifestEntry {
    pub name: *mut c_char,
    pub type_: GxrBindingType,
}

impl ::std::fmt::Debug for GxrActionManifestEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrActionManifestEntry @ {self:p}"))
         .field("name", &self.name)
         .field("type_", &self.type_)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrActionSetClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GxrActionSetClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrActionSetClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrAnalogEvent {
    pub active: gboolean,
    pub state: graphene::graphene_vec3_t,
    pub delta: graphene::graphene_vec3_t,
    pub controller: *mut GxrController,
    pub time: c_float,
}

impl ::std::fmt::Debug for GxrAnalogEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrAnalogEvent @ {self:p}"))
         .field("active", &self.active)
         .field("state", &self.state)
         .field("delta", &self.delta)
         .field("controller", &self.controller)
         .field("time", &self.time)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrBinding {
    pub action: *mut GxrActionManifestEntry,
    pub input_paths: *mut glib::GSList,
}

impl ::std::fmt::Debug for GxrBinding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrBinding @ {self:p}"))
         .field("action", &self.action)
         .field("input_paths", &self.input_paths)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrBindingManifest {
    pub filename: *mut c_char,
    pub gxr_bindings: *mut glib::GSList,
    pub interaction_profile: *mut c_char,
}

impl ::std::fmt::Debug for GxrBindingManifest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrBindingManifest @ {self:p}"))
         .field("filename", &self.filename)
         .field("gxr_bindings", &self.gxr_bindings)
         .field("interaction_profile", &self.interaction_profile)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrBindingPath {
    pub component: GxrBindingComponent,
    pub path: *mut c_char,
    pub mode: GxrBindingMode,
}

impl ::std::fmt::Debug for GxrBindingPath {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrBindingPath @ {self:p}"))
         .field("component", &self.component)
         .field("path", &self.path)
         .field("mode", &self.mode)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrContextClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GxrContextClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrContextClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrControllerClass {
    pub parent_class: GxrDeviceClass,
}

impl ::std::fmt::Debug for GxrControllerClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrControllerClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrDeviceClass {
    pub parent: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GxrDeviceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrDeviceClass @ {self:p}"))
         .field("parent", &self.parent)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrDeviceManagerClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GxrDeviceManagerClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrDeviceManagerClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrDigitalEvent {
    pub active: gboolean,
    pub state: gboolean,
    pub changed: gboolean,
    pub controller: *mut GxrController,
    pub time: c_float,
}

impl ::std::fmt::Debug for GxrDigitalEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrDigitalEvent @ {self:p}"))
         .field("active", &self.active)
         .field("state", &self.state)
         .field("changed", &self.changed)
         .field("controller", &self.controller)
         .field("time", &self.time)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrManifestClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GxrManifestClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrManifestClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrOverlayEvent {
    pub main_session_visible: bool,
}

impl ::std::fmt::Debug for GxrOverlayEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrOverlayEvent @ {self:p}"))
         .field("main_session_visible", &self.main_session_visible)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrPose {
    pub transformation: graphene::graphene_matrix_t,
    pub is_valid: gboolean,
}

impl ::std::fmt::Debug for GxrPose {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrPose @ {self:p}"))
         .field("transformation", &self.transformation)
         .field("is_valid", &self.is_valid)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrPoseEvent {
    pub active: gboolean,
    pub pose: graphene::graphene_matrix_t,
    pub velocity: graphene::graphene_vec3_t,
    pub angular_velocity: graphene::graphene_vec3_t,
    pub valid: gboolean,
    pub device_connected: gboolean,
    pub controller: *mut GxrController,
}

impl ::std::fmt::Debug for GxrPoseEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrPoseEvent @ {self:p}"))
         .field("active", &self.active)
         .field("pose", &self.pose)
         .field("velocity", &self.velocity)
         .field("angular_velocity", &self.angular_velocity)
         .field("valid", &self.valid)
         .field("device_connected", &self.device_connected)
         .field("controller", &self.controller)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrStateChangeEvent {
    pub state_change: GxrStateChange,
}

impl ::std::fmt::Debug for GxrStateChangeEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrStateChangeEvent @ {self:p}"))
         .field("state_change", &self.state_change)
         .finish()
    }
}

// Classes
#[repr(C)]
pub struct GxrAction {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GxrAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrAction @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct GxrActionSet {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GxrActionSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrActionSet @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct GxrContext {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GxrContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrContext @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct GxrController {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GxrController {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrController @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GxrDevice {
    pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for GxrDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrDevice @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
pub struct GxrDeviceManager {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GxrDeviceManager {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrDeviceManager @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct GxrManifest {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GxrManifest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GxrManifest @ {self:p}"))
         .finish()
    }
}

#[link(name = "gxr-0.16")]
extern "C" {

    //=========================================================================
    // GxrAction
    //=========================================================================
    pub fn gxr_action_get_type() -> GType;
    pub fn gxr_action_new(context: *mut GxrContext) -> *mut GxrAction;
    pub fn gxr_action_new_from_type_url(context: *mut GxrContext, action_set: *mut GxrActionSet, type_: GxrActionType, url: *mut c_char) -> *mut GxrAction;
    pub fn gxr_action_sets_poll(sets: *mut *mut GxrActionSet, count: u32) -> gboolean;
    pub fn gxr_action_emit_analog(self_: *mut GxrAction, event: *mut GxrAnalogEvent);
    pub fn gxr_action_emit_digital(self_: *mut GxrAction, event: *mut GxrDigitalEvent);
    pub fn gxr_action_emit_pose(self_: *mut GxrAction, event: *mut GxrPoseEvent);
    pub fn gxr_action_get_action_set(self_: *mut GxrAction) -> *mut GxrActionSet;
    pub fn gxr_action_get_action_type(self_: *mut GxrAction) -> GxrActionType;
    pub fn gxr_action_get_handle(self_: *mut GxrAction) -> *mut c_void;
    pub fn gxr_action_get_haptic_action(self_: *mut GxrAction) -> *mut GxrAction;
    pub fn gxr_action_get_num_bindings(self_: *mut GxrAction) -> u32;
    pub fn gxr_action_get_url(self_: *mut GxrAction) -> *mut c_char;
    pub fn gxr_action_poll(self_: *mut GxrAction) -> gboolean;
    pub fn gxr_action_set_action_set(self_: *mut GxrAction, action_set: *mut GxrActionSet);
    pub fn gxr_action_set_action_type(self_: *mut GxrAction, type_: GxrActionType);
    pub fn gxr_action_set_bindings(self_: *mut GxrAction, bindings: *mut c_void);
    pub fn gxr_action_set_digital_from_float_haptic(self_: *mut GxrAction, haptic_action: *mut GxrAction);
    pub fn gxr_action_set_digital_from_float_threshold(self_: *mut GxrAction, threshold: c_float);
    pub fn gxr_action_set_url(self_: *mut GxrAction, url: *mut c_char);
    pub fn gxr_action_trigger_haptic(self_: *mut GxrAction, start_seconds_from_now: c_float, duration_seconds: c_float, frequency: c_float, amplitude: c_float, controller_handle: u64) -> gboolean;
    pub fn gxr_action_update_controllers(self_: *mut GxrAction);

    //=========================================================================
    // GxrActionSet
    //=========================================================================
    pub fn gxr_action_set_get_type() -> GType;
    pub fn gxr_action_set_new_from_url(context: *mut GxrContext, manifest: *mut GxrManifest, url: *mut c_char) -> *mut GxrActionSet;
    pub fn gxr_action_set_append_action(self_: *mut GxrActionSet, action: *mut GxrAction);
    pub fn gxr_action_set_connect(self_: *mut GxrActionSet, type_: GxrActionType, url: *mut c_char, callback: gobject::GCallback, data: gpointer) -> gboolean;
    pub fn gxr_action_set_connect_digital_from_float(self_: *mut GxrActionSet, url: *mut c_char, threshold: c_float, haptic_url: *mut c_char, callback: gobject::GCallback, data: gpointer) -> *mut GxrAction;
    pub fn gxr_action_set_get_actions(self_: *mut GxrActionSet) -> *mut glib::GSList;
    pub fn gxr_action_set_get_handle(self_: *mut GxrActionSet) -> *mut c_void;
    pub fn gxr_action_set_get_manifest(self_: *mut GxrActionSet) -> *mut GxrManifest;

    //=========================================================================
    // GxrContext
    //=========================================================================
    pub fn gxr_context_get_type() -> GType;
    pub fn gxr_context_new(app_name: *mut c_char, app_version: u32) -> *mut GxrContext;
    pub fn gxr_context_new_from_vulkan_extensions(instance_ext_list: *mut glib::GSList, device_ext_list: *mut glib::GSList, app_name: *mut c_char, app_version: u32) -> *mut GxrContext;
    pub fn gxr_context_attach_action_sets(self_: *mut GxrContext, sets: *mut *mut GxrActionSet, count: u32) -> gboolean;
    pub fn gxr_context_begin_frame(self_: *mut GxrContext) -> gboolean;
    pub fn gxr_context_end_frame(self_: *mut GxrContext) -> gboolean;
    pub fn gxr_context_get_acquired_framebuffer(self_: *mut GxrContext) -> *mut gulkan::GulkanFrameBuffer;
    pub fn gxr_context_get_buffer_index(self_: *mut GxrContext) -> u32;
    pub fn gxr_context_get_device_manager(self_: *mut GxrContext) -> *mut GxrDeviceManager;
    pub fn gxr_context_get_eye_position(self_: *mut GxrContext, eye: GxrEye, v: *mut graphene::graphene_vec3_t);
    pub fn gxr_context_get_framebuffer_at(self_: *mut GxrContext, i: u32) -> *mut gulkan::GulkanFrameBuffer;
    pub fn gxr_context_get_frustum_angles(self_: *mut GxrContext, eye: GxrEye, left: *mut c_float, right: *mut c_float, top: *mut c_float, bottom: *mut c_float);
    pub fn gxr_context_get_gulkan(self_: *mut GxrContext) -> *mut gulkan::GulkanContext;
    pub fn gxr_context_get_head_pose(self_: *mut GxrContext, pose: *mut graphene::graphene_matrix_t) -> gboolean;
    pub fn gxr_context_get_projection(self_: *mut GxrContext, eye: GxrEye, near: c_float, far: c_float, mat: *mut graphene::graphene_matrix_t);
    pub fn gxr_context_get_runtime_device_extensions(self_: *mut GxrContext, out_list: *mut *mut glib::GSList) -> gboolean;
    pub fn gxr_context_get_runtime_instance_extensions(self_: *mut GxrContext, out_list: *mut *mut glib::GSList) -> gboolean;
    pub fn gxr_context_get_swapchain_extent(self_: *mut GxrContext, view_index: u32) -> vulkan::VkExtent2D;
    pub fn gxr_context_get_swapchain_length(self_: *mut GxrContext) -> u32;
    pub fn gxr_context_get_view(self_: *mut GxrContext, eye: GxrEye, mat: *mut graphene::graphene_matrix_t);
    pub fn gxr_context_init_framebuffers(self_: *mut GxrContext, extent: vulkan::VkExtent2D, sample_count: vulkan::VkSampleCountFlagBits, render_pass: *mut *mut gulkan::GulkanRenderPass) -> gboolean;
    pub fn gxr_context_poll_events(self_: *mut GxrContext);
    pub fn gxr_context_request_quit(self_: *mut GxrContext);
    pub fn gxr_context_wait_frame(self_: *mut GxrContext) -> gboolean;

    //=========================================================================
    // GxrController
    //=========================================================================
    pub fn gxr_controller_get_type() -> GType;
    pub fn gxr_controller_new(controller_handle: u64) -> *mut GxrController;
    pub fn gxr_controller_get_hand_grip_pose(self_: *mut GxrController, pose: *mut graphene::graphene_matrix_t);
    pub fn gxr_controller_get_pointer_pose(self_: *mut GxrController, pose: *mut graphene::graphene_matrix_t) -> gboolean;
    pub fn gxr_controller_is_pointer_pose_valid(self_: *mut GxrController) -> gboolean;
    pub fn gxr_controller_update_hand_grip_pose(self_: *mut GxrController, event: *mut GxrPoseEvent);
    pub fn gxr_controller_update_pointer_pose(self_: *mut GxrController, event: *mut GxrPoseEvent);

    //=========================================================================
    // GxrDevice
    //=========================================================================
    pub fn gxr_device_get_type() -> GType;
    pub fn gxr_device_new(device_id: u64) -> *mut GxrDevice;
    pub fn gxr_device_get_handle(self_: *mut GxrDevice) -> u64;
    pub fn gxr_device_get_transformation_direct(self_: *mut GxrDevice, mat: *mut graphene::graphene_matrix_t);
    pub fn gxr_device_initialize(self_: *mut GxrDevice) -> gboolean;
    pub fn gxr_device_is_controller(self_: *mut GxrDevice) -> gboolean;
    pub fn gxr_device_is_pose_valid(self_: *mut GxrDevice) -> gboolean;
    pub fn gxr_device_set_handle(self_: *mut GxrDevice, handle: u64);
    pub fn gxr_device_set_is_pose_valid(self_: *mut GxrDevice, valid: bool);
    pub fn gxr_device_set_transformation_direct(self_: *mut GxrDevice, mat: *mut graphene::graphene_matrix_t);

    //=========================================================================
    // GxrDeviceManager
    //=========================================================================
    pub fn gxr_device_manager_get_type() -> GType;
    pub fn gxr_device_manager_new() -> *mut GxrDeviceManager;
    pub fn gxr_device_manager_add(self_: *mut GxrDeviceManager, device_id: u64, is_controller: bool) -> gboolean;
    pub fn gxr_device_manager_connect_pose_actions(self_: *mut GxrDeviceManager, action_set: *mut GxrActionSet, pointer_pose_url: *mut c_char, hand_grip_pose_url: *mut c_char);
    pub fn gxr_device_manager_get(self_: *mut GxrDeviceManager, device_id: u64) -> *mut GxrDevice;
    pub fn gxr_device_manager_get_controllers(self_: *mut GxrDeviceManager) -> *mut glib::GSList;
    pub fn gxr_device_manager_get_devices(self_: *mut GxrDeviceManager) -> *mut glib::GList;
    pub fn gxr_device_manager_remove(self_: *mut GxrDeviceManager, device_id: u64);
    pub fn gxr_device_manager_update_poses(self_: *mut GxrDeviceManager, poses: *mut GxrPose);

    //=========================================================================
    // GxrManifest
    //=========================================================================
    pub fn gxr_manifest_get_type() -> GType;
    pub fn gxr_manifest_new(resource_path: *const c_char, manifest_name: *const c_char) -> *mut GxrManifest;
    pub fn gxr_manifest_get_binding_filenames(self_: *mut GxrManifest) -> *mut glib::GSList;
    pub fn gxr_manifest_get_binding_manifests(manifest: *mut GxrManifest) -> *mut glib::GSList;
    pub fn gxr_manifest_load_actions(self_: *mut GxrManifest, action_stream: *mut gio::GInputStream) -> gboolean;
    pub fn gxr_manifest_load_bindings(self_: *mut GxrManifest, resource_path: *const c_char) -> gboolean;

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn gxr_io_create_directory_if_needed(path: *mut c_char) -> gboolean;
    pub fn gxr_io_get_cache_path(dir_name: *const c_char) -> *mut glib::GString;
    pub fn gxr_io_write_resource_to_file(res_base_path: *const c_char, cache_path: *mut c_char, file_name: *const c_char, file_path: *mut glib::GString) -> gboolean;

}
