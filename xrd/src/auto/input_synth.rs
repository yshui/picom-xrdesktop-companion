// Generated by gir (https://github.com/gtk-rs/gir @ 2358cc24efd2)
// from ../gir-files (@ eab91ba8f88b)
// from ../xrd-gir-files (@ 2f1ef32fd867)
// DO NOT EDIT

use crate::{Window};
use glib::{prelude::*,signal::{connect_raw, SignalHandlerId},translate::*};
use std::{boxed::Box as Box_,fmt,mem::transmute};

glib::wrapper! {
    #[doc(alias = "XrdInputSynth")]
    pub struct InputSynth(Object<ffi::XrdInputSynth, ffi::XrdInputSynthClass>);

    match fn {
        type_ => || ffi::xrd_input_synth_get_type(),
    }
}

impl InputSynth {
    //#[doc(alias = "xrd_input_synth_new")]
    //pub fn new(g3k: /*Ignored*/&g3k::Context) -> InputSynth {
    //    unsafe { TODO: call ffi:xrd_input_synth_new() }
    //}

    //#[doc(alias = "xrd_input_synth_create_action_set")]
    //pub fn create_action_set(&self, manifest: /*Ignored*/&gxr::Manifest) -> /*Ignored*/Option<gxr::ActionSet> {
    //    unsafe { TODO: call ffi:xrd_input_synth_create_action_set() }
    //}

    #[doc(alias = "xrd_input_synth_move_cursor")]
    pub fn move_cursor(&self, window: &Window, controller_pose: &mut graphene::Matrix, intersection: &mut graphene::Point3D) {
        unsafe {
            ffi::xrd_input_synth_move_cursor(self.to_glib_none().0, window.to_glib_none().0, controller_pose.to_glib_none_mut().0, intersection.to_glib_none_mut().0);
        }
    }

    /// Issue a button release event for every button that previously was used for a
    /// button press event, but has not been released yet.
    ///
    /// When calling this function, also consider [`reset_scroll()`][Self::reset_scroll()].
    #[doc(alias = "xrd_input_synth_reset_press_state")]
    pub fn reset_press_state(&self) {
        unsafe {
            ffi::xrd_input_synth_reset_press_state(self.to_glib_none().0);
        }
    }

    /// Resets the internal state of the scrolling, so the in-flight scroll distance
    /// on the touchpad is discarded.
    ///
    /// When calling this function, also consider [`reset_press_state()`][Self::reset_press_state()]
    #[doc(alias = "xrd_input_synth_reset_scroll")]
    pub fn reset_scroll(&self) {
        unsafe {
            ffi::xrd_input_synth_reset_scroll(self.to_glib_none().0);
        }
    }

    #[doc(alias = "click-event")]
    pub fn connect_click_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn click_event_trampoline<F: Fn(&InputSynth, &gdk::Event) + Send + 'static>(this: *mut ffi::XrdInputSynth, object: *mut gdk::ffi::GdkEvent, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), &from_glib_none(object))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"click-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(click_event_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "move-cursor-event")]
    pub fn connect_move_cursor_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn move_cursor_event_trampoline<F: Fn(&InputSynth, &gdk::Event) + Send + 'static>(this: *mut ffi::XrdInputSynth, object: *mut gdk::ffi::GdkEvent, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), &from_glib_none(object))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"move-cursor-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(move_cursor_event_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }
}

unsafe impl Send for InputSynth {}

impl fmt::Display for InputSynth {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("InputSynth")
    }
}
