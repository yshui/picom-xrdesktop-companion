// Generated by gir (https://github.com/gtk-rs/gir @ 2358cc24efd2)
// from ../gir-files (@ eab91ba8f88b)
// from ../xrd-gir-files (@ 3896faadf111)
// DO NOT EDIT

use crate::Window;
use glib::{
    prelude::*,
    signal::{connect_raw, SignalHandlerId},
    translate::*,
};
use std::{boxed::Box as Box_, fmt, mem::transmute};

glib::wrapper! {
    #[doc(alias = "XrdInputSynth")]
    pub struct InputSynth(Object<ffi::XrdInputSynth, ffi::XrdInputSynthClass>);

    match fn {
        type_ => || ffi::xrd_input_synth_get_type(),
    }
}

impl InputSynth {
    #[doc(alias = "xrd_input_synth_new")]
    pub fn new() -> InputSynth {
        unsafe { from_glib_full(ffi::xrd_input_synth_new()) }
    }

    //#[doc(alias = "xrd_input_synth_create_action_set")]
    //pub fn create_action_set(&self, context: &impl IsA<gxr::Context>) -> /*Ignored*/Option<gxr::ActionSet> {
    //    unsafe { TODO: call ffi:xrd_input_synth_create_action_set() }
    //}

    ///
    /// # Returns
    ///
    /// The GxrController that is used for input synth.
    #[doc(alias = "xrd_input_synth_get_primary_controller")]
    #[doc(alias = "get_primary_controller")]
    pub fn primary_controller(&self) -> Option<gxr::Controller> {
        unsafe {
            from_glib_none(ffi::xrd_input_synth_get_primary_controller(
                self.to_glib_none().0,
            ))
        }
    }

    /// ## `controller`
    /// The index of the controller that will be used for input synth.
    #[doc(alias = "xrd_input_synth_make_primary")]
    pub fn make_primary(&self, controller: &gxr::Controller) {
        unsafe {
            ffi::xrd_input_synth_make_primary(self.to_glib_none().0, controller.to_glib_none().0);
        }
    }

    #[doc(alias = "xrd_input_synth_move_cursor")]
    pub fn move_cursor(
        &self,
        window: &impl IsA<Window>,
        controller_pose: &mut graphene::Matrix,
        intersection: &mut graphene::Point3D,
    ) {
        unsafe {
            ffi::xrd_input_synth_move_cursor(
                self.to_glib_none().0,
                window.as_ref().to_glib_none().0,
                controller_pose.to_glib_none_mut().0,
                intersection.to_glib_none_mut().0,
            );
        }
    }

    /// Issue a button release event for every button that previously was used for a
    /// button press event, but has not been released yet.
    ///
    /// When calling this function, also consider [`reset_scroll()`][Self::reset_scroll()].
    #[doc(alias = "xrd_input_synth_reset_press_state")]
    pub fn reset_press_state(&self) {
        unsafe {
            ffi::xrd_input_synth_reset_press_state(self.to_glib_none().0);
        }
    }

    /// Resets the internal state of the scrolling, so the in-flight scroll distance
    /// on the touchpad is discarded.
    ///
    /// When calling this function, also consider [`reset_press_state()`][Self::reset_press_state()]
    #[doc(alias = "xrd_input_synth_reset_scroll")]
    pub fn reset_scroll(&self) {
        unsafe {
            ffi::xrd_input_synth_reset_scroll(self.to_glib_none().0);
        }
    }

    #[doc(alias = "click-event")]
    pub fn connect_click_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn click_event_trampoline<
            F: Fn(&InputSynth, &gdk::Event) + Send + 'static,
        >(
            this: *mut ffi::XrdInputSynth,
            object: *mut gdk::ffi::GdkEvent,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), &from_glib_none(object))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"click-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    click_event_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }

    #[doc(alias = "move-cursor-event")]
    pub fn connect_move_cursor_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(
        &self,
        f: F,
    ) -> SignalHandlerId {
        unsafe extern "C" fn move_cursor_event_trampoline<
            F: Fn(&InputSynth, &gdk::Event) + Send + 'static,
        >(
            this: *mut ffi::XrdInputSynth,
            object: *mut gdk::ffi::GdkEvent,
            f: glib::ffi::gpointer,
        ) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), &from_glib_none(object))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(
                self.as_ptr() as *mut _,
                b"move-cursor-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(
                    move_cursor_event_trampoline::<F> as *const (),
                )),
                Box_::into_raw(f),
            )
        }
    }
}

impl Default for InputSynth {
    fn default() -> Self {
        Self::new()
    }
}

unsafe impl Send for InputSynth {}

impl fmt::Display for InputSynth {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("InputSynth")
    }
}
