// Generated by gir (https://github.com/gtk-rs/gir @ e0d8d8d645b1)
// from ../gir-files (@ 54ae87ae2ece)
// from ../xrd-gir-files (@ 5e1250e9c217)
// DO NOT EDIT

use crate::Client;
use glib::object::Cast;
use glib::object::IsA;
use glib::signal::connect_raw;
use glib::signal::SignalHandlerId;
use glib::translate::*;
use glib::StaticType;
use glib::ToValue;
use std::boxed::Box as Box_;
use std::fmt;
use std::mem::transmute;

glib::wrapper! {
    #[doc(alias = "XrdWindow")]
    pub struct Window(Interface<ffi::XrdWindow, ffi::XrdWindowInterface>);

    match fn {
        type_ => || ffi::xrd_window_get_type(),
    }
}

impl Window {
        pub const NONE: Option<&'static Window> = None;
    

    //#[doc(alias = "xrd_window_new_from_data")]
    //pub fn new_from_data(self_: &impl IsA<Client>, data: /*Ignored*/&mut WindowData) -> Option<Window> {
    //    unsafe { TODO: call ffi:xrd_window_new_from_data() }
    //}

    /// ## `client`
    /// a [`Client`][crate::Client]
    /// ## `title`
    /// the title
    /// ## `width`
    /// the width
    /// ## `height`
    /// the height
    /// ## `ppm`
    /// the ppm
    ///
    /// # Returns
    ///
    /// a new [`Window`][crate::Window]
    #[doc(alias = "xrd_window_new_from_meters")]
    pub fn new_from_meters(client: &impl IsA<Client>, title: &str, width: f32, height: f32, ppm: f32) -> Option<Window> {
        unsafe {
            from_glib_full(ffi::xrd_window_new_from_meters(client.as_ref().to_glib_none().0, title.to_glib_none().0, width, height, ppm))
        }
    }

    //#[doc(alias = "xrd_window_new_from_native")]
    //pub fn new_from_native(client: &impl IsA<Client>, title: &str, native: /*Unimplemented*/Option<Fundamental: Pointer>, width_pixels: u32, height_pixels: u32, ppm: f32) -> Option<Window> {
    //    unsafe { TODO: call ffi:xrd_window_new_from_native() }
    //}

    /// ## `client`
    /// a [`Client`][crate::Client]
    /// ## `title`
    /// the title
    /// ## `width`
    /// the width
    /// ## `height`
    /// the height
    /// ## `ppm`
    /// the ppm
    ///
    /// # Returns
    ///
    /// a new [`Window`][crate::Window]
    #[doc(alias = "xrd_window_new_from_pixels")]
    pub fn new_from_pixels(client: &impl IsA<Client>, title: &str, width: u32, height: u32, ppm: f32) -> Option<Window> {
        unsafe {
            from_glib_full(ffi::xrd_window_new_from_pixels(client.as_ref().to_glib_none().0, title.to_glib_none().0, width, height, ppm))
        }
    }
}

unsafe impl Send for Window {}

/// Trait containing all [`struct@Window`] methods.
///
/// # Implementors
///
/// [`Window`][struct@crate::Window]
pub trait WindowExt: 'static {
    //#[doc(alias = "xrd_window_add_child")]
    //fn add_child(&self, child: &impl IsA<Window>, offset_center: /*Ignored*/&mut graphene::Point);

    #[doc(alias = "xrd_window_close")]
    fn close(&self);

    #[doc(alias = "xrd_window_deselect")]
    fn deselect(&self);

    //#[doc(alias = "xrd_window_emit_grab")]
    //fn emit_grab(&self, event: /*Ignored*/&mut GrabEvent);

    #[doc(alias = "xrd_window_emit_grab_start")]
    fn emit_grab_start(&self, controller: &gxr::Controller);

    //#[doc(alias = "xrd_window_emit_hover")]
    //fn emit_hover(&self, event: /*Ignored*/&mut HoverEvent);

    #[doc(alias = "xrd_window_emit_hover_end")]
    fn emit_hover_end(&self, controller: &gxr::Controller);

    #[doc(alias = "xrd_window_emit_hover_start")]
    fn emit_hover_start(&self, controller: &gxr::Controller);

    #[doc(alias = "xrd_window_emit_release")]
    fn emit_release(&self, controller: &gxr::Controller);

    #[doc(alias = "xrd_window_end_selection")]
    fn end_selection(&self);

    #[doc(alias = "xrd_window_get_aspect_ratio")]
    #[doc(alias = "get_aspect_ratio")]
    fn aspect_ratio(&self) -> f32;

    ///
    /// # Returns
    ///
    /// The current world space height of the window in meters.
    #[doc(alias = "xrd_window_get_current_height_meters")]
    #[doc(alias = "get_current_height_meters")]
    fn current_height_meters(&self) -> f32;

    #[doc(alias = "xrd_window_get_current_ppm")]
    #[doc(alias = "get_current_ppm")]
    fn current_ppm(&self) -> f32;

    ///
    /// # Returns
    ///
    /// The current world space width of the window in meters.
    #[doc(alias = "xrd_window_get_current_width_meters")]
    #[doc(alias = "get_current_width_meters")]
    fn current_width_meters(&self) -> f32;

    //#[doc(alias = "xrd_window_get_data")]
    //#[doc(alias = "get_data")]
    //fn data(&self) -> /*Ignored*/Option<WindowData>;

    #[doc(alias = "xrd_window_get_initial_ppm")]
    #[doc(alias = "get_initial_ppm")]
    fn initial_ppm(&self) -> f32;

    //#[doc(alias = "xrd_window_get_intersection_2d")]
    //#[doc(alias = "get_intersection_2d")]
    //fn intersection_2d(&self, intersection_3d: &mut graphene::Point3D, intersection_2d: /*Ignored*/&mut graphene::Point);

    //#[doc(alias = "xrd_window_get_intersection_2d_pixels")]
    //#[doc(alias = "get_intersection_2d_pixels")]
    //fn intersection_2d_pixels(&self, intersection_3d: &mut graphene::Point3D, intersection_pixels: /*Ignored*/&mut graphene::Point);

    //#[doc(alias = "xrd_window_get_normal")]
    //#[doc(alias = "get_normal")]
    //fn normal(&self, normal: /*Ignored*/&mut graphene::Vec3);

    //#[doc(alias = "xrd_window_get_plane")]
    //#[doc(alias = "get_plane")]
    //fn plane(&self, res: /*Ignored*/&mut graphene::Plane);

    #[doc(alias = "xrd_window_get_reset_transformation")]
    #[doc(alias = "get_reset_transformation")]
    fn reset_transformation(&self, transform: &mut graphene::Matrix);

    ///
    /// # Returns
    ///
    /// The last [`gulkan::Texture`][crate::gulkan::Texture] submitted with
    /// [`submit_texture()`][Self::submit_texture()], or [`None`] if none has been submitted so far.
    #[doc(alias = "xrd_window_get_texture")]
    #[doc(alias = "get_texture")]
    fn texture(&self) -> Option<gulkan::Texture>;

    #[doc(alias = "xrd_window_get_transformation")]
    #[doc(alias = "get_transformation")]
    fn is_transformation(&self, mat: &mut graphene::Matrix) -> bool;

    #[doc(alias = "xrd_window_get_transformation_no_scale")]
    #[doc(alias = "get_transformation_no_scale")]
    fn is_transformation_no_scale(&self, mat: &mut graphene::Matrix) -> bool;

    #[doc(alias = "xrd_window_hide")]
    fn hide(&self);

    #[doc(alias = "xrd_window_is_pinned")]
    fn is_pinned(&self) -> bool;

    #[doc(alias = "xrd_window_is_selected")]
    fn is_selected(&self) -> bool;

    #[doc(alias = "xrd_window_is_visible")]
    fn is_visible(&self) -> bool;

    /// Must be called periodically to receive events from this window.
    #[doc(alias = "xrd_window_poll_event")]
    fn poll_event(&self);

    #[doc(alias = "xrd_window_save_reset_transformation")]
    fn save_reset_transformation(&self);

    #[doc(alias = "xrd_window_select")]
    fn select(&self);

    /// For performance reason it is a good idea to not set a new texture every
    /// time the window content changes. Instead the the cached texture should be
    /// acquired with [`texture()`][Self::texture()] and resubmitted with
    /// [`submit_texture()`][Self::submit_texture()]..
    /// If the window/texture size changes, a new texture should be submitted
    /// (the previous submitted texture does not need to be unref'ed).
    ///
    /// This function also submits the `texture`.
    /// ## `texture`
    /// A [`gulkan::Texture`][crate::gulkan::Texture] that is created by the caller.
    /// Ownership of this texture is transferred to the [`Window`][crate::Window].
    #[doc(alias = "xrd_window_set_and_submit_texture")]
    fn set_and_submit_texture(&self, texture: &gulkan::Texture);

    //#[doc(alias = "xrd_window_set_color")]
    //fn set_color(&self, color: /*Ignored*/&graphene::Vec3);

    #[doc(alias = "xrd_window_set_flip_y")]
    fn set_flip_y(&self, flip_y: bool);

    /// ## `pinned`
    /// The pin status to set this window to
    /// ## `hide_unpinned`
    /// If TRUE, the window will be hidden if it is unpinned, and
    /// shown if it is pinned. This corresponds to the "show only pinned windows"
    /// mode set up in [`Client`][crate::Client].
    /// If FALSE, windows are always shown.
    /// Note that `hide_unpinned` only determines initial visibility, and does not
    /// keep track of further mode changes.
    #[doc(alias = "xrd_window_set_pin")]
    fn set_pin(&self, pinned: bool, hide_unpinned: bool);

    /// ## `transform`
    /// A transformation matrix to save as reset transform.
    #[doc(alias = "xrd_window_set_reset_transformation")]
    fn set_reset_transformation(&self, transform: &mut graphene::Matrix);

    #[doc(alias = "xrd_window_set_transformation")]
    fn set_transformation(&self, mat: &mut graphene::Matrix) -> bool;

    #[doc(alias = "xrd_window_show")]
    fn show(&self);

    #[doc(alias = "xrd_window_submit_texture")]
    fn submit_texture(&self);

    #[doc(alias = "xrd_window_update_child")]
    fn update_child(&self);

    #[doc(alias = "initial-height-meters")]
    fn initial_height_meters(&self) -> f32;

    #[doc(alias = "initial-height-meters")]
    fn set_initial_height_meters(&self, initial_height_meters: f32);

    #[doc(alias = "initial-width-meters")]
    fn initial_width_meters(&self) -> f32;

    #[doc(alias = "initial-width-meters")]
    fn set_initial_width_meters(&self, initial_width_meters: f32);

    //fn native(&self) -> /*Unimplemented*/Fundamental: Pointer;

    //fn set_native(&self, native: /*Unimplemented*/Fundamental: Pointer);

    fn scale(&self) -> f32;

    fn set_scale(&self, scale: f32);

    #[doc(alias = "texture-height")]
    fn texture_height(&self) -> u32;

    #[doc(alias = "texture-height")]
    fn set_texture_height(&self, texture_height: u32);

    #[doc(alias = "texture-width")]
    fn texture_width(&self) -> u32;

    #[doc(alias = "texture-width")]
    fn set_texture_width(&self, texture_width: u32);

    fn title(&self) -> Option<glib::GString>;

    #[doc(alias = "button-press-event")]
    fn connect_button_press_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "button-release-event")]
    fn connect_button_release_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "destroy")]
    fn connect_destroy<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "grab-event")]
    fn connect_grab_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "grab-start-event")]
    fn connect_grab_start_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "hover-end-event")]
    fn connect_hover_end_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "hover-event")]
    fn connect_hover_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "hover-start-event")]
    fn connect_hover_start_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "keyboard-close-event")]
    fn connect_keyboard_close_event<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "keyboard-press-event")]
    fn connect_keyboard_press_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "motion-notify-event")]
    fn connect_motion_notify_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "release-event")]
    fn connect_release_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "scroll-event")]
    fn connect_scroll_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "show")]
    fn connect_show<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "initial-height-meters")]
    fn connect_initial_height_meters_notify<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "initial-width-meters")]
    fn connect_initial_width_meters_notify<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "native")]
    fn connect_native_notify<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "scale")]
    fn connect_scale_notify<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "texture-height")]
    fn connect_texture_height_notify<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId;

    #[doc(alias = "texture-width")]
    fn connect_texture_width_notify<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId;
}

impl<O: IsA<Window>> WindowExt for O {
    //fn add_child(&self, child: &impl IsA<Window>, offset_center: /*Ignored*/&mut graphene::Point) {
    //    unsafe { TODO: call ffi:xrd_window_add_child() }
    //}

    fn close(&self) {
        unsafe {
            ffi::xrd_window_close(self.as_ref().to_glib_none().0);
        }
    }

    fn deselect(&self) {
        unsafe {
            ffi::xrd_window_deselect(self.as_ref().to_glib_none().0);
        }
    }

    //fn emit_grab(&self, event: /*Ignored*/&mut GrabEvent) {
    //    unsafe { TODO: call ffi:xrd_window_emit_grab() }
    //}

    fn emit_grab_start(&self, controller: &gxr::Controller) {
        unsafe {
            ffi::xrd_window_emit_grab_start(self.as_ref().to_glib_none().0, controller.to_glib_none().0);
        }
    }

    //fn emit_hover(&self, event: /*Ignored*/&mut HoverEvent) {
    //    unsafe { TODO: call ffi:xrd_window_emit_hover() }
    //}

    fn emit_hover_end(&self, controller: &gxr::Controller) {
        unsafe {
            ffi::xrd_window_emit_hover_end(self.as_ref().to_glib_none().0, controller.to_glib_none().0);
        }
    }

    fn emit_hover_start(&self, controller: &gxr::Controller) {
        unsafe {
            ffi::xrd_window_emit_hover_start(self.as_ref().to_glib_none().0, controller.to_glib_none().0);
        }
    }

    fn emit_release(&self, controller: &gxr::Controller) {
        unsafe {
            ffi::xrd_window_emit_release(self.as_ref().to_glib_none().0, controller.to_glib_none().0);
        }
    }

    fn end_selection(&self) {
        unsafe {
            ffi::xrd_window_end_selection(self.as_ref().to_glib_none().0);
        }
    }

    fn aspect_ratio(&self) -> f32 {
        unsafe {
            ffi::xrd_window_get_aspect_ratio(self.as_ref().to_glib_none().0)
        }
    }

    fn current_height_meters(&self) -> f32 {
        unsafe {
            ffi::xrd_window_get_current_height_meters(self.as_ref().to_glib_none().0)
        }
    }

    fn current_ppm(&self) -> f32 {
        unsafe {
            ffi::xrd_window_get_current_ppm(self.as_ref().to_glib_none().0)
        }
    }

    fn current_width_meters(&self) -> f32 {
        unsafe {
            ffi::xrd_window_get_current_width_meters(self.as_ref().to_glib_none().0)
        }
    }

    //fn data(&self) -> /*Ignored*/Option<WindowData> {
    //    unsafe { TODO: call ffi:xrd_window_get_data() }
    //}

    fn initial_ppm(&self) -> f32 {
        unsafe {
            ffi::xrd_window_get_initial_ppm(self.as_ref().to_glib_none().0)
        }
    }

    //fn intersection_2d(&self, intersection_3d: &mut graphene::Point3D, intersection_2d: /*Ignored*/&mut graphene::Point) {
    //    unsafe { TODO: call ffi:xrd_window_get_intersection_2d() }
    //}

    //fn intersection_2d_pixels(&self, intersection_3d: &mut graphene::Point3D, intersection_pixels: /*Ignored*/&mut graphene::Point) {
    //    unsafe { TODO: call ffi:xrd_window_get_intersection_2d_pixels() }
    //}

    //fn normal(&self, normal: /*Ignored*/&mut graphene::Vec3) {
    //    unsafe { TODO: call ffi:xrd_window_get_normal() }
    //}

    //fn plane(&self, res: /*Ignored*/&mut graphene::Plane) {
    //    unsafe { TODO: call ffi:xrd_window_get_plane() }
    //}

    fn reset_transformation(&self, transform: &mut graphene::Matrix) {
        unsafe {
            ffi::xrd_window_get_reset_transformation(self.as_ref().to_glib_none().0, transform.to_glib_none_mut().0);
        }
    }

    fn texture(&self) -> Option<gulkan::Texture> {
        unsafe {
            from_glib_none(ffi::xrd_window_get_texture(self.as_ref().to_glib_none().0))
        }
    }

    fn is_transformation(&self, mat: &mut graphene::Matrix) -> bool {
        unsafe {
            from_glib(ffi::xrd_window_get_transformation(self.as_ref().to_glib_none().0, mat.to_glib_none_mut().0))
        }
    }

    fn is_transformation_no_scale(&self, mat: &mut graphene::Matrix) -> bool {
        unsafe {
            from_glib(ffi::xrd_window_get_transformation_no_scale(self.as_ref().to_glib_none().0, mat.to_glib_none_mut().0))
        }
    }

    fn hide(&self) {
        unsafe {
            ffi::xrd_window_hide(self.as_ref().to_glib_none().0);
        }
    }

    fn is_pinned(&self) -> bool {
        unsafe {
            from_glib(ffi::xrd_window_is_pinned(self.as_ref().to_glib_none().0))
        }
    }

    fn is_selected(&self) -> bool {
        unsafe {
            from_glib(ffi::xrd_window_is_selected(self.as_ref().to_glib_none().0))
        }
    }

    fn is_visible(&self) -> bool {
        unsafe {
            from_glib(ffi::xrd_window_is_visible(self.as_ref().to_glib_none().0))
        }
    }

    fn poll_event(&self) {
        unsafe {
            ffi::xrd_window_poll_event(self.as_ref().to_glib_none().0);
        }
    }

    fn save_reset_transformation(&self) {
        unsafe {
            ffi::xrd_window_save_reset_transformation(self.as_ref().to_glib_none().0);
        }
    }

    fn select(&self) {
        unsafe {
            ffi::xrd_window_select(self.as_ref().to_glib_none().0);
        }
    }

    fn set_and_submit_texture(&self, texture: &gulkan::Texture) {
        unsafe {
            ffi::xrd_window_set_and_submit_texture(self.as_ref().to_glib_none().0, texture.to_glib_full());
        }
    }

    //fn set_color(&self, color: /*Ignored*/&graphene::Vec3) {
    //    unsafe { TODO: call ffi:xrd_window_set_color() }
    //}

    fn set_flip_y(&self, flip_y: bool) {
        unsafe {
            ffi::xrd_window_set_flip_y(self.as_ref().to_glib_none().0, flip_y.into_glib());
        }
    }

    fn set_pin(&self, pinned: bool, hide_unpinned: bool) {
        unsafe {
            ffi::xrd_window_set_pin(self.as_ref().to_glib_none().0, pinned.into_glib(), hide_unpinned.into_glib());
        }
    }

    fn set_reset_transformation(&self, transform: &mut graphene::Matrix) {
        unsafe {
            ffi::xrd_window_set_reset_transformation(self.as_ref().to_glib_none().0, transform.to_glib_none_mut().0);
        }
    }

    fn set_transformation(&self, mat: &mut graphene::Matrix) -> bool {
        unsafe {
            from_glib(ffi::xrd_window_set_transformation(self.as_ref().to_glib_none().0, mat.to_glib_none_mut().0))
        }
    }

    fn show(&self) {
        unsafe {
            ffi::xrd_window_show(self.as_ref().to_glib_none().0);
        }
    }

    fn submit_texture(&self) {
        unsafe {
            ffi::xrd_window_submit_texture(self.as_ref().to_glib_none().0);
        }
    }

    fn update_child(&self) {
        unsafe {
            ffi::xrd_window_update_child(self.as_ref().to_glib_none().0);
        }
    }

    fn initial_height_meters(&self) -> f32 {
        glib::ObjectExt::property(self.as_ref(), "initial-height-meters")
    }

    fn set_initial_height_meters(&self, initial_height_meters: f32) {
        glib::ObjectExt::set_property(self.as_ref(),"initial-height-meters", &initial_height_meters)
    }

    fn initial_width_meters(&self) -> f32 {
        glib::ObjectExt::property(self.as_ref(), "initial-width-meters")
    }

    fn set_initial_width_meters(&self, initial_width_meters: f32) {
        glib::ObjectExt::set_property(self.as_ref(),"initial-width-meters", &initial_width_meters)
    }

    //fn native(&self) -> /*Unimplemented*/Fundamental: Pointer {
    //    glib::ObjectExt::property(self.as_ref(), "native")
    //}

    //fn set_native(&self, native: /*Unimplemented*/Fundamental: Pointer) {
    //    glib::ObjectExt::set_property(self.as_ref(),"native", &native)
    //}

    fn scale(&self) -> f32 {
        glib::ObjectExt::property(self.as_ref(), "scale")
    }

    fn set_scale(&self, scale: f32) {
        glib::ObjectExt::set_property(self.as_ref(),"scale", &scale)
    }

    fn texture_height(&self) -> u32 {
        glib::ObjectExt::property(self.as_ref(), "texture-height")
    }

    fn set_texture_height(&self, texture_height: u32) {
        glib::ObjectExt::set_property(self.as_ref(),"texture-height", &texture_height)
    }

    fn texture_width(&self) -> u32 {
        glib::ObjectExt::property(self.as_ref(), "texture-width")
    }

    fn set_texture_width(&self, texture_width: u32) {
        glib::ObjectExt::set_property(self.as_ref(),"texture-width", &texture_width)
    }

    fn title(&self) -> Option<glib::GString> {
        glib::ObjectExt::property(self.as_ref(), "title")
    }

    fn connect_button_press_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn button_press_event_trampoline<P: IsA<Window>, F: Fn(&P, &gdk::Event) + Send + 'static>(this: *mut ffi::XrdWindow, object: *mut gdk::ffi::GdkEvent, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_none(object))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"button-press-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(button_press_event_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_button_release_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn button_release_event_trampoline<P: IsA<Window>, F: Fn(&P, &gdk::Event) + Send + 'static>(this: *mut ffi::XrdWindow, object: *mut gdk::ffi::GdkEvent, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_none(object))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"button-release-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(button_release_event_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_destroy<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn destroy_trampoline<P: IsA<Window>, F: Fn(&P) + Send + 'static>(this: *mut ffi::XrdWindow, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"destroy\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(destroy_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_grab_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn grab_event_trampoline<P: IsA<Window>, F: Fn(&P, &gdk::Event) + Send + 'static>(this: *mut ffi::XrdWindow, object: *mut gdk::ffi::GdkEvent, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_none(object))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"grab-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(grab_event_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_grab_start_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn grab_start_event_trampoline<P: IsA<Window>, F: Fn(&P, &gdk::Event) + Send + 'static>(this: *mut ffi::XrdWindow, object: *mut gdk::ffi::GdkEvent, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_none(object))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"grab-start-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(grab_start_event_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_hover_end_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn hover_end_event_trampoline<P: IsA<Window>, F: Fn(&P, &gdk::Event) + Send + 'static>(this: *mut ffi::XrdWindow, object: *mut gdk::ffi::GdkEvent, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_none(object))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"hover-end-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(hover_end_event_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_hover_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn hover_event_trampoline<P: IsA<Window>, F: Fn(&P, &gdk::Event) + Send + 'static>(this: *mut ffi::XrdWindow, object: *mut gdk::ffi::GdkEvent, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_none(object))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"hover-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(hover_event_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_hover_start_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn hover_start_event_trampoline<P: IsA<Window>, F: Fn(&P, &gdk::Event) + Send + 'static>(this: *mut ffi::XrdWindow, object: *mut gdk::ffi::GdkEvent, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_none(object))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"hover-start-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(hover_start_event_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_keyboard_close_event<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn keyboard_close_event_trampoline<P: IsA<Window>, F: Fn(&P) + Send + 'static>(this: *mut ffi::XrdWindow, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"keyboard-close-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(keyboard_close_event_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_keyboard_press_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn keyboard_press_event_trampoline<P: IsA<Window>, F: Fn(&P, &gdk::Event) + Send + 'static>(this: *mut ffi::XrdWindow, object: *mut gdk::ffi::GdkEvent, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_none(object))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"keyboard-press-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(keyboard_press_event_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_motion_notify_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn motion_notify_event_trampoline<P: IsA<Window>, F: Fn(&P, &gdk::Event) + Send + 'static>(this: *mut ffi::XrdWindow, object: *mut gdk::ffi::GdkEvent, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_none(object))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"motion-notify-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(motion_notify_event_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_release_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn release_event_trampoline<P: IsA<Window>, F: Fn(&P, &gdk::Event) + Send + 'static>(this: *mut ffi::XrdWindow, object: *mut gdk::ffi::GdkEvent, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_none(object))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"release-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(release_event_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_scroll_event<F: Fn(&Self, &gdk::Event) + Send + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn scroll_event_trampoline<P: IsA<Window>, F: Fn(&P, &gdk::Event) + Send + 'static>(this: *mut ffi::XrdWindow, object: *mut gdk::ffi::GdkEvent, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_none(object))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"scroll-event\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(scroll_event_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_show<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn show_trampoline<P: IsA<Window>, F: Fn(&P) + Send + 'static>(this: *mut ffi::XrdWindow, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"show\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(show_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_initial_height_meters_notify<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_initial_height_meters_trampoline<P: IsA<Window>, F: Fn(&P) + Send + 'static>(this: *mut ffi::XrdWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::initial-height-meters\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_initial_height_meters_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_initial_width_meters_notify<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_initial_width_meters_trampoline<P: IsA<Window>, F: Fn(&P) + Send + 'static>(this: *mut ffi::XrdWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::initial-width-meters\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_initial_width_meters_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_native_notify<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_native_trampoline<P: IsA<Window>, F: Fn(&P) + Send + 'static>(this: *mut ffi::XrdWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::native\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_native_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_scale_notify<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_scale_trampoline<P: IsA<Window>, F: Fn(&P) + Send + 'static>(this: *mut ffi::XrdWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::scale\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_scale_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_texture_height_notify<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_texture_height_trampoline<P: IsA<Window>, F: Fn(&P) + Send + 'static>(this: *mut ffi::XrdWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::texture-height\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_texture_height_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    fn connect_texture_width_notify<F: Fn(&Self) + Send + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_texture_width_trampoline<P: IsA<Window>, F: Fn(&P) + Send + 'static>(this: *mut ffi::XrdWindow, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(Window::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, b"notify::texture-width\0".as_ptr() as *const _,
                Some(transmute::<_, unsafe extern "C" fn()>(notify_texture_width_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl fmt::Display for Window {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.write_str("Window")
    }
}
