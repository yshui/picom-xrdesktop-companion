// Generated by gir (https://github.com/gtk-rs/gir @ 2358cc24efd2)
// from ../../gir-files (@ eab91ba8f88b)
// from ../../xrd-gir-files (@ 2f1ef32fd867)
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(clippy::approx_constant, clippy::type_complexity, clippy::unreadable_literal, clippy::upper_case_acronyms)]
#![cfg_attr(feature = "dox", feature(doc_cfg))]


#[allow(unused_imports)]
use libc::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong,
    c_void, size_t, ssize_t, intptr_t, uintptr_t, FILE};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

// Enums
pub type XrdInputSynthButton = c_int;
pub const LEFT_BUTTON: XrdInputSynthButton = 1;
pub const MIDDLE_BUTTON: XrdInputSynthButton = 2;
pub const RIGHT_BUTTON: XrdInputSynthButton = 3;
pub const SCROLL_UP: XrdInputSynthButton = 4;
pub const SCROLL_DOWN: XrdInputSynthButton = 5;
pub const SCROLL_LEFT: XrdInputSynthButton = 6;
pub const SCROLL_RIGHT: XrdInputSynthButton = 7;

// Constants
pub const XRD_TIP_VIEWPORT_SCALE: c_int = 3;

// Records
#[derive(Copy, Clone)]
#[repr(C)]
pub struct XrdClickEvent {
    pub object: *mut g3k::G3kObject,
    pub position: *mut graphene::graphene_point_t,
    pub button: XrdInputSynthButton,
    pub state: gboolean,
    pub controller: *mut g3k::G3kController,
}

impl ::std::fmt::Debug for XrdClickEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdClickEvent @ {self:p}"))
         .field("object", &self.object)
         .field("position", &self.position)
         .field("button", &self.button)
         .field("state", &self.state)
         .field("controller", &self.controller)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct XrdInputSynthClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for XrdInputSynthClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdInputSynthClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct XrdMoveCursorEvent {
    pub window: *mut XrdWindow,
    pub position: *mut graphene::graphene_point_t,
    pub ignore: gboolean,
}

impl ::std::fmt::Debug for XrdMoveCursorEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdMoveCursorEvent @ {self:p}"))
         .field("window", &self.window)
         .field("position", &self.position)
         .field("ignore", &self.ignore)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct XrdShakeCompensatorClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for XrdShakeCompensatorClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdShakeCompensatorClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct XrdShellClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for XrdShellClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdShellClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct XrdWindowClass {
    pub parent_class: g3k::G3kPlaneClass,
}

impl ::std::fmt::Debug for XrdWindowClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdWindowClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct XrdWindowRect {
    pub bl: XrdWindowRectPoint,
    pub tr: XrdWindowRectPoint,
}

impl ::std::fmt::Debug for XrdWindowRect {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdWindowRect @ {self:p}"))
         .field("bl", &self.bl)
         .field("tr", &self.tr)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct XrdWindowRectPoint {
    pub x: u32,
    pub y: u32,
}

impl ::std::fmt::Debug for XrdWindowRectPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdWindowRectPoint @ {self:p}"))
         .field("x", &self.x)
         .field("y", &self.y)
         .finish()
    }
}

// Classes
#[repr(C)]
pub struct XrdInputSynth {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for XrdInputSynth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdInputSynth @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct XrdShakeCompensator {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for XrdShakeCompensator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdShakeCompensator @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct XrdShell {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for XrdShell {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdShell @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
pub struct XrdWindow {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for XrdWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("XrdWindow @ {self:p}"))
         .finish()
    }
}

#[link(name = "xrdesktop-0.16")]
extern "C" {

    //=========================================================================
    // XrdInputSynth
    //=========================================================================
    pub fn xrd_input_synth_get_type() -> GType;
    pub fn xrd_input_synth_new(g3k: *mut g3k::G3kContext) -> *mut XrdInputSynth;
    pub fn xrd_input_synth_create_action_set(self_: *mut XrdInputSynth, manifest: *mut gxr::GxrManifest) -> *mut gxr::GxrActionSet;
    pub fn xrd_input_synth_move_cursor(self_: *mut XrdInputSynth, window: *mut XrdWindow, controller_pose: *mut graphene::graphene_matrix_t, intersection: *mut graphene::graphene_point3d_t);
    pub fn xrd_input_synth_reset_press_state(self_: *mut XrdInputSynth);
    pub fn xrd_input_synth_reset_scroll(self_: *mut XrdInputSynth);

    //=========================================================================
    // XrdShakeCompensator
    //=========================================================================
    pub fn xrd_shake_compensator_get_type() -> GType;
    pub fn xrd_shake_compensator_new() -> *mut XrdShakeCompensator;
    pub fn xrd_shake_compensator_get_button(self_: *mut XrdShakeCompensator) -> XrdInputSynthButton;
    pub fn xrd_shake_compensator_is_drag(self_: *mut XrdShakeCompensator, window: *mut XrdWindow, controller_pose: *mut graphene::graphene_matrix_t, intersection: *mut graphene::graphene_point3d_t) -> gboolean;
    pub fn xrd_shake_compensator_is_recording(self_: *mut XrdShakeCompensator) -> gboolean;
    pub fn xrd_shake_compensator_record(self_: *mut XrdShakeCompensator, position: *mut graphene::graphene_point_t);
    pub fn xrd_shake_compensator_replay_move_queue(self_: *mut XrdShakeCompensator, synth: *mut XrdInputSynth, move_cursor_event_signal: c_uint, hover_window: *mut XrdWindow);
    pub fn xrd_shake_compensator_reset(self_: *mut XrdShakeCompensator);
    pub fn xrd_shake_compensator_start_recording(self_: *mut XrdShakeCompensator, button: XrdInputSynthButton);

    //=========================================================================
    // XrdShell
    //=========================================================================
    pub fn xrd_shell_get_type() -> GType;
    pub fn xrd_shell_new() -> *mut XrdShell;
    pub fn xrd_shell_new_from_g3k(g3k: *mut g3k::G3kContext) -> *mut XrdShell;
    pub fn xrd_shell_new_from_vulkan_extensions(instance_ext_list: *mut glib::GSList, device_ext_list: *mut glib::GSList) -> *mut XrdShell;
    pub fn xrd_shell_add_button(self_: *mut XrdShell, button: *mut g3k::G3kButton, position: *mut graphene::graphene_point3d_t, press_callback: gobject::GCallback, press_callback_data: gpointer, parent: *mut g3k::G3kObject);
    pub fn xrd_shell_add_window(self_: *mut XrdShell, window: *mut XrdWindow, parent: *mut g3k::G3kObject, draggable: gboolean, lookup_key: gpointer);
    pub fn xrd_shell_get_desktop_cursor(self_: *mut XrdShell) -> *mut g3k::G3kCursor;
    pub fn xrd_shell_get_g3k(self_: *mut XrdShell) -> *mut g3k::G3kContext;
    pub fn xrd_shell_get_input_synth(self_: *mut XrdShell) -> *mut XrdInputSynth;
    pub fn xrd_shell_get_keyboard(self_: *mut XrdShell) -> *mut g3k::G3kKeyboard;
    pub fn xrd_shell_get_keyboard_window(self_: *mut XrdShell) -> *mut XrdWindow;
    pub fn xrd_shell_get_synth_hovered(self_: *mut XrdShell) -> *mut XrdWindow;
    pub fn xrd_shell_lookup_window(self_: *mut XrdShell, key: gpointer) -> *mut XrdWindow;
    pub fn xrd_shell_poll_runtime_events(self_: *mut XrdShell) -> gboolean;
    pub fn xrd_shell_remove_window(self_: *mut XrdShell, window: *mut XrdWindow);
    pub fn xrd_shell_set_pin(self_: *mut XrdShell, win: *mut XrdWindow, pin: gboolean);
    pub fn xrd_shell_show_pinned_only(self_: *mut XrdShell, pinned_only: gboolean);

    //=========================================================================
    // XrdWindow
    //=========================================================================
    pub fn xrd_window_get_type() -> GType;
    pub fn xrd_window_new(g3k: *mut g3k::G3kContext, title: *const c_char, native: gpointer, size_pixels: vulkan::VkExtent2D, size_meters: *mut graphene::graphene_size_t) -> *mut XrdWindow;
    pub fn xrd_window_add_child(self_: *mut XrdWindow, child: *mut XrdWindow);
    pub fn xrd_window_close(self_: *mut XrdWindow);
    pub fn xrd_window_get_parent(self_: *mut XrdWindow) -> *mut XrdWindow;
    pub fn xrd_window_get_pixel_intersection(self_: *mut XrdWindow, intersection_3d: *mut graphene::graphene_point3d_t, intersection_pixels: *mut graphene::graphene_point_t);
    pub fn xrd_window_get_rect(self_: *mut XrdWindow) -> *mut XrdWindowRect;
    pub fn xrd_window_has_parent(self_: *mut XrdWindow) -> gboolean;
    pub fn xrd_window_is_pinned(self_: *mut XrdWindow) -> gboolean;
    pub fn xrd_window_is_selected(self_: *mut XrdWindow) -> gboolean;
    pub fn xrd_window_reset_color(self_: *mut XrdWindow);
    pub fn xrd_window_set_color(self_: *mut XrdWindow, color: *const graphene::graphene_vec4_t);
    pub fn xrd_window_set_flip_y(self_: *mut XrdWindow, flip_y: gboolean);
    pub fn xrd_window_set_pin(self_: *mut XrdWindow, pinned: gboolean, hide_unpinned: gboolean);
    pub fn xrd_window_set_rect(self_: *mut XrdWindow, rect: *mut XrdWindowRect);
    pub fn xrd_window_set_selection_color(self_: *mut XrdWindow, is_selected: gboolean);

}
